<!DOCTYPE html>
<head>
<title> <div style="text-decoration: underline"> <b>Segmento TCP, Trasporto</b> </div> </title>
<meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="generator" content="Org-mode"><meta name="author" content="Matteo Lugli üêÉ">
<link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@5.2/distr/fira_code.css">
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>
<style>
    .theme-light {
	--color-primary: black;
	--color-background: white;
	--color-text: black;
    }

    .theme-dark {
    
	--color-primary: #23b0ff;
	--color-background: #21202C;
	--color-text: white;
    }
    
    body {
	font-family: 'Fira Code', monospace;
	font-size: 20px;
	background-color: white;
    }

    div#menu {
	position: sticky;
	position: -webkit-sticky;
	top: 5px;
	z-index: 30;
    }

    div#menu button {
	right: 0px;
	position: absolute;
    }
    .src{
        background-color:white;
        color:black;
    }
    p {
	color: var(black);
    }

    h1,h3, h4, h5, a {
	color: var(black);
    }
    h2{
        color:#337ab7;
    }

    .title{
        text-decoration: underline;
        font-weight:bold;
    }

    nav a {
	color: var(black);
    }

    nav a:hover {
	color: var(black);
	text-decoration: none;
    }

    ul li, ol li {
	color: var(black);
    }

    .collapsible {
        background-color: white;
	border: none;
	text-align: left;
    }
    
    .top-buffer { margin-top: 18px; }

    figcaption { font-size: 15px; }

    footer { 
        text-align: center; 
        background-color: #FFFFEA;
    }

    .observation {
	border-style: solid;
	margin-top: 20px;
	margin-bottom: 20px;
    }

    pre {
	font-size: 20px;
	background-color: black;
	color: white;
	inline-size: 900px;
	overflow: auto;
	word-wrap: normal;
    }
    blockquote {
	border-left: 5px solid var(black);
        background-color: #ffffEA;
        font-size: 20px;
    }
    .MathJax_SVG_Display{
        color:black;
    }

    blockquote p {
	color: var(black);
    }

    /* side-menu stuff */
    .side-menu {
	position: fixed;
	left: 0;
	width: 60px;
	height: 100%;
	z-index: 100;
    }

    .side-menu-content {
	display: none;
	position: absolute;
	top: 60px;
	left: 0px;
	height: 100%;
	/* background-color: var(black); */
	z-index: 100;	
    }

    .side-menu-content ul {
	list-style-type: none;
	position: relative;
	margin-left: 5px;
	width: 100%;
	padding-left: 0px;
    }

    .side-menu-content ul li {
	position: relative;
	padding-top: 5px;
	font-size: 15px;
	padding-left: 0px;
    }

    .side-menu-content ul li a {
	color: var(black);
	text-decoration: none;
	font-weight: bold;
    }

    .toggle {
	position: absolute;
	display: block;
	top: 0;
	left: 0;
	width: 80px;
	height: 60px;
	background: var(white);
    }

    .toggle:hover {
	background: var(black);
    }

    .toggle:before {
	content: '\f0c9';
	font-family: fontAwesome;
	position: absolute;
	width: 100%;
	height: 100%;
	line-height: 60px;
	text-align: center;
	font-size: 24px;
	color: var(black);
    }

    @media (max-width: 1024px) {
	pre {
	    inline-size: 600px;
	}
    }

    @media (max-width: 576px) {
	* {
	    font-size: 10px;
	}

	h1 {
	    font-size: 13px;           
	}

	h2, h3, h4, h5 {
	    font-size: 12px;
	}

	blockquote {
	    font-size: 15px;
	}

	pre, li pre {
	    font-size: 10px;
	    color: white;
	    inline-size: 300px;
	    word-wrap: normal;
	    overflow: auto;
	}

        li pre {
	    inline-size: 250px;
        }

	.toggle {
	    width: 30px;
	}

	.toggle:before {
	    content: '\f0c9';
	    font-family: fontAwesome;
	    position: absolute;
	    width: 100%;
	    height: 100%;
	    line-height: 60px;
	    text-align: center;
	    font-size: 12px;
	    color: var(black);
	}	
    }


</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="content" class="container">

<div class="row top-buffer"> </div>

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><h1 class="title"><div style="text-decoration: underline"> <b>Segmento TCP, Trasporto</b> </div></h1>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->
<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><hr style="border: 1px solid #FFFFFF" />   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->
<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-" style="text-decoration: underline">  Info &triangledown;</h2>
</button><div class='sec- collapsible-content'>
<p>
Appunti della lezione in presenza del 22/11/22;
</p>
</div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-1" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-1" style="text-decoration: underline"> 1 Formato del frammento &triangledown;</h2>
</button><div id="outline-container-sec-1-1" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-1-1" nil> 1.1 Campi &triangledown;</h3>
</button><div class='sec-1-1 collapsible-content'>
<p>

<div class="row top-buffer"> </div>
<img src="./frammento1.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>
<ul class="org-ul">
<li><p>
<b>Sequence number</b>: identificativo del segmento all'interno del
flusso che si sta inviando/ricevendo;
</p>
</li>
<li><p>
<b>Ack number</b>: serve per comunicare quali segmenti sono stati ricevuti
correttamente. E' strettamente legato al sequence number, √® leggermente diverso;
Viene inserito anche questo campo perch√® i messaggi di conferma
possono anch'essi inviare dati normalmente. E' un modo per
diminuire il numero di pacchetti inviati.
</p>
</li>

<li><p>
<b>Hlen</b>: indica la dimensione dell'header TCP, che pu√≤ essere variabile.
Infatti alla fine dell'header possono essere aggiunti dei campi aggiuntivi.
Hlen ragiona in multipli di 4 byte: infatti dopo TCP options si applica
un padding per rendere il tutto un multiplo di 32 bit.
</p>
</li>
<li><p>
<b>Code bit</b>: Bitmask di 6 bit, ognuno ha un ruolo diverso.
</p>
<ul class="org-ul">
<li><p>
<b>URG</b>: campo poco utilizzato, servirebbe a comunicare la presenza di 
dati urgenti. (Ci sono dati pi√π importanti di altri tra quelli che si
stanno inviando). Ora √® utilizzato poco.
</p>
</li>
<li><p>
<b>ACK</b>: se == 1, indica che questo √® il pacchetto di acknowledgment.
</p>
</li>
<li><p>
<b>PSH</b>: bit che viene usato per inviare i dati senza passare per il buffer.
Usato dall'applicazione mittente quando si vuole svuotare il buffer immediatamente.
Esempio: invio di un file pacchettizzato a livello TCP. L'ultimo pacchetto avr√†
il bit push attivato, richiedendo lo svuotamento del buffer e l'invio dei dati,
dato che non ne arriveranno altri. Pu√≤ essere utile (ad esempio) quando si vuole usare TCP per implementare
delle applicazioni <i>real-time</i>, anche se di base non √® consigliato perch√®
TCP √® un protocollo <b>asincrono</b>.
</p>
</li>
<li><p>
<b>SYN</b>, <b>FIN</b>, <b>RST</b>: bit che sono a 1 solo in fasi di apertura/
chiusura della connessione. Syn √® il bit di <b>sincronizzazione</b>, √® settato
a 1 nei pacchetti mandati durante la fase di apertura della connessione,
mentre FIN e RST sono a 1 in fase di chiusura. Essi rappresentano due diversi
modi (<i>polite e non polite</i>) di chiudere una connessione. Si vedranno approfondimenti
successivamente.
</p>
</li>
</ul>
</li>
<li><p>
<b>Window size</b>:destinatario e mittente si informano su quanti
dati possono ancora essere immagazzinati all'interno del buffer.
Magari il mittente rallenta il flusso dati sapendo che il destinatario
ha poco spazio nel buffer.
</p>
</li>
<li><p>
<b>Urgent Pointer</b>: in teoria serve per specificare quali sono i dati
urgenti ma √® una funzionalit√† usata molto raramente.
</p>
</li>
<li><p>
<b>TCP Options</b>: comunica qual'√® la dimensione massima in cui segmentare
il flusso, ossia l'<b>MSS</b> (ci si torna successivamente);
</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-1-2" nil> 1.2 MSS &triangledown;</h3>
</button><div class='sec-1-2 collapsible-content'>
<p>
L'MSS √® l'informazione specificata dal TCP Pointer. Se non √® specificata, allora si usa <b>536 byte.</b>
Ovviamente si punta ad avere l'MSS massima possibile (inviare pacchetti pi√π grandi significa inviare
meno pacchetti, quindi migliorare le performance) ma si cerca anche di rimanere in un "range" tale 
per cui non si debba applicare la frammentazione a livello H2N.
(Infatti bisogna "rientrare" nell'MTU).
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-1-3" nil> 1.3 Sequence Number &triangledown;</h3>
</button><div class='sec-1-3 collapsible-content'>
<p>
I sequence number idealmente sono da 0 a \(2^{32}-1\), in realt√†
viene aggiunto un offset iniziale, per una ragione di sicurezza.
Ovviamente se si finiscono i sequence number per una determinata
connessione, si riparte da 0, ovviamente con l'offset aggiunto.
</p>

<p>
üëâ si supponga di dover trasferire un file di 500kByte, con MSS = 1000byte.
I sequence number saranno \(X\), \(X+1000\), \(X+2000\),... dove \(X\) indica l'<b>ISN</b>,
ossia l'offset iniziale.
</p>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-1-4" nil> 1.4 Ack Number &triangledown;</h3>
</button><div class='sec-1-4 collapsible-content'>
<p>
Sequence number che identifica <b>il prossimo byte</b> che l'host A (sender) si aspetta di ricevere da B(receiver).
Serve ad indicare la corretta ricezione del pacchetto precedente.
</p>
</div>
</div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-2" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-2" style="text-decoration: underline"> 2 Fasi di una connessione &triangledown;</h2>
</button><div id="outline-container-sec-2-1" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-2-1" nil> 2.1 Apertura (Three-way Handshake) &triangledown;</h3>
</button><div class='sec-2-1 collapsible-content'>
<p>
Solo in questa fase vengono distinti i ruoli client/server.
</p>
<ul class="org-ul">
<li><p>
<i>I pacchetti in questione hanno ovviamente il campo SYN == 1</i>,
ossia i pacchetti riservati all'apertura della connessione.
</p>
</li>
</ul>
<p>
Ovviamente ci interessa soltanto la porta destinataria, su cui
il server dev'essere in ascolto. Le informazioni relative all'indirizzo
IP verranno gestite dal livello 3.
Il client comunica l'offset di partenza della sequenza, definendo
l'<b>ISN</b> (<i>Initial Sequence Number</i>). Questo valore viene scelto
"casualmente", per ragioni appunto di sicurezza.
Serve per contare i dati che <i>dal client vanno verso il server</i>, 
quando il server deve rispondere comunicher√† un'altro ISN. 
</p>

<p>
Il segmento SYN <b>del client</b> contiene anche:
</p>
<ul class="org-ul">
<li><p>
la <b>MRW</b> (<i>maximum receive window</i>): il client comunica al server
quanto √® grande il suo buffer. E' utile perch√® TCP √® pensato
per funzionare su architetture eterogenee.
</p>
</li>
<li><p>
<b>MSS</b>, ossia la massima dimensione del segmento. E' una <b>proposta</b>
da parte del client, che pu√≤ essere ritrattata in futuro. Infatti
i due host potrebbero essere dispositivi molto diversi tra loro, 
aventi caratteristiche hardware e necessit√† diverse.
</p>
</li>
<li><p>
<b>ASSENZA del payload</b>: questi pacchetti non trasportano altri dati.
</p>
</li>
</ul>
<hr >
<p>
Il server risponde con un pacchetto SYN, a sua volta.
Questo pacchetto ha anche il bit di ack == 1, dato che si conferma
l'apertura della connessione. Il pacchetto prende quindi
comunemente il nome di <b>SYN/ACK</b> \(\Downarrow\)
</p>

<p>

<div class="row top-buffer"> </div>
<img src="./frammento2.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>

<p>
risposta \(\Downarrow\)
</p>

<p>

<div class="row top-buffer"> </div>
<img src="./frammento3.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-2-2" nil> 2.2 Scambio di dati &triangledown;</h3>
</button><div class='sec-2-2 collapsible-content'>
<p>
Verr√† trattato in futuro.
In generale √® utile ricordarsi del meccanismo di <b>PiggyBacking</b>, cio√® l'inserimento
dell'informazione di ack all'interno di pacchetti che trasportano anche dati utili.
E' un'ottimizzazione usata per inviare meno pacchetti, quindi per migliorare la connessione.
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-2-3" nil> 2.3 Chiusura &triangledown;</h3>
</button><div id="outline-container-sec-2-3-1" class="outline-4"><button type="button" class="collapsible">
<h4 id="sec-2-3-1" nil> 2.3.1 Polite &triangledown;</h4>
</button><div class='sec-2-3-1 collapsible-content'>
<p>
Modalit√† di chiusura con affidabilit√†, usata quando non si
ha urgenza di chiudere la connessione.
</p>
<ul class="org-ul">
<li><p>
Chi decide di chiudere la connessione invia un pacchetto con
<b>FIN</b> settato a 1.
</p>
</li>
<li><p>
Chi riceve questo pacchetto, risponde confermando semplicemente 
la ricezione del FIN.
Quando l'applicazione √® pronta per essere chiusa, invia a sua
volta un pacchetto con FIN settato a 1.
</p>
</li>
<li><p>
Il sender iniziale riceve un FIN, e invia a sua volta un ACK,
confermando il FIN precedente.
Vengono effetuati degli "sleep" per assicurare la chiusura
corretta dei servizi.
</p>
</li>
</ul>

<p>

<div class="row top-buffer"> </div>
<img src="./frammento4.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>

<p>
Il client considera "chiusa" la connessione soltanto dopo un <b>timeout</b> 
finale.
Questa "attesa" √® dovuta al fatto che potrebbero essere in circolazione
ancora dei pacchetti legati ad altre comunicazioni. Si riescono
quindi a gestire anche situazioni "anomale".
</p>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4"><button type="button" class="collapsible">
<h4 id="sec-2-3-2" nil> 2.3.2 un-Polite &triangledown;</h4>
</button><div class='sec-2-3-2 collapsible-content'>
<p>
Protocollo di chiusura best-effort per chiudere la connessione velocemente, che si basa
sull'invio di pacchetti/segnali RST.
Potrebbe essere usato (ad esempio) da un web-server se nota che un client
inizia a mandare dei pacchetti che non seguono il protocollo TCP, ossia
dei pacchetti "anomali".

<div class="row top-buffer"> </div>
<img src="./frammento5.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>
</div>
</div>
</div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-3" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-3" style="text-decoration: underline"> 3 Affidabilit√† del protocollo &triangledown;</h2>
</button><div id="outline-container-sec-3-1" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-3-1" nil> 3.1 Stop and Wait &triangledown;</h3>
</button><div class='sec-3-1 collapsible-content'>
<p>
Se il mittente di un pacchetto non riceve l'acknowledgment da parte
del destinatario dopo un certo timeout, li prova a ri-inviare.
</p>
<ul class="org-ul">
<li><p>
<i>Come si fa a "stimare" il timeout?</i>
</p>
</li>
</ul>
<p>
üëâ ovviamente dipende dalla rete: in una rete locale
potrebbe essere pi√π basso rispetto alla rete globale.
Ovviamente essendo TCP un protocollo adattativo e general purpose,
il timeout deve essere calcolato e stimato.
</p>
<ul class="org-ul">
<li><p>
<b>RTT</b> (<i>round trip time</i>): tempo osservabile tra l'arrivo di 
un ack e il pacchetto confermato. E' un calcolo basato soltanto
sulla vista del mittente. In generale l'idea √® che 
il timeout finale deve essere maggiore dell'RTT minimo osservato
nella comunicazione.
</p>
</li>
</ul>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4"><button type="button" class="collapsible">
<h4 id="sec-3-1-1" nil> 3.1.1 Approcci per il calcolo dell'RTT &triangledown;</h4>
</button><div class='sec-3-1-1 collapsible-content'>
<ul class="org-ul">
<li><p>
Si usa il doppio della media rispetto agli ultimi \(n\) round trip 
time. E' il metodo pi√π semplice, non richede la stima del round trip time.
</p>
</li>

<li><p>
In alternativa, si pu√≤ <i>stimare</i> il prossimo
round trip time, per poi calcolare il timeout. I due passi sono i seguenti:
</p>
<ol class="org-ol">
<li><p>
<b>EstimatedRTT</b>: √® un calcolo "on the fly" in cui si da molto
peso all'ultimo RTT osservato, quelli precedenti vengono
man-mano assorbiti. Infatti quelli pi√π "vecchi" hanno meno 
valenza: il loro peso cala <b>esponenzialmente</b>. E'
essenzialmente una media calcolata "in movimento", dove:
</p>
<ul class="org-ul">
<li><p>
\(E_{rtt}(t)\) \(\rightarrow\) Round Trip Time stimato al tempo t;
</p>
</li>
<li><p>
\(x*S_{rtt}(t)\) \(\rightarrow\) Rond Trip Time stimato al tempo t;
</p>
</li>
</ul>
</li>
<li><p>
<b>Calcolo del timeout</b>. Le formule dei passaggi sono le seguenti: \(\Downarrow\)  
</p>
</li>
</ol>
</li>
</ul>
\begin{equation}
E_{rtt}(t) = (1-x)*E_{rtt}(t-1) + x*S_{rtt}(t)
\end{equation}
\begin{equation}
Timeout(t) = E_{rtt}(t) + 4*\sigma(t)
\end{equation}

<p>
Esperimenti mostrano che la formula √® molto resistente
agli outlier.
</p>

<p>

<div class="row top-buffer"> </div>
<img src="./frammento6.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>


<hr >
</div>
</div>
</div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->

<div class="row top-buffer"> </div>

<div class="row top-buffer"> </div>

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><hr style="border: 1px solid #FFFFFF" />   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->
<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><footer id="postamble">
<div>
<p class="author"><b>Author</b>: Matteo Lugli üêÉ</p><p class="email"><b>Email</b>: <a href="mailto:matteolugli18@gmail.com">matteolugli18@gmail.com</a></p><p class="date"><b>Created</b>: 2022-12-13 Tue 14:13</p>
</div>
</footer>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->
<div class="row top-buffer"> </div>

<div class="row top-buffer"> </div>

<div class="row top-buffer"> </div>
<script>

      function set_sections() {
	// -- Deal with the hiding/showing of the various sections
	var buttons = document.getElementsByClassName('collapsible');

	for (var i = 0; i < buttons.length; i++) {
	  buttons[i].addEventListener('click', function() {
	    var content = this.parentElement;
	    divs = content.getElementsByTagName('div');
	    for (var j = 0; j < divs.length; j++) {
	      if (divs[j].style.display === '' || divs[j].style.display === 'block') {
		divs[j].style.display = 'none';
	      } else {
		divs[j].style.display = 'block';
	      }
	    }
	  });
	}
      }

      function hide_sections() {
	// -- Deal with the hiding/showing of the various sections
	var buttons = document.getElementsByClassName('collapsible');
	var sections_to_not_hide = ['Lecture Info', 'Overview', 'Basic Info', 'Informazioni Lezione', 'Table of Contents', 'Informazioni', 'Lecture Summary']

	for (var i = 0; i < buttons.length; i++) {
	  // -- Check which sections to hide initially
	  html_elem = buttons[i].getElementsByTagName('h2').length > 0 ?
	    buttons[i].getElementsByTagName('h2')[0] :
	    buttons[i].getElementsByTagName('h3').length > 0 ?
	    buttons[i].getElementsByTagName('h3')[0] :
	    buttons[i].getElementsByTagName('h4')[0];

	  var hide_section = true;

	  for (var h = 0; h < sections_to_not_hide.length; h++) {
	    if (html_elem.innerHTML.includes(sections_to_not_hide[h])) {
	      hide_section = false;
	    }
	  }

	  if (hide_section) {
	    divs = buttons[i].parentElement.getElementsByTagName('div');

	    for (var j = 0; j < divs.length; j++) {
	      divs[j].style.display =
		divs[j].style.display === '' || divs[j].style.display === 'block' ?
		divs[j].style.display = 'none' :
		divs[j].style.display = 'block';
	    }
	  }    
	}
      }

      // ---------------------------

      // function to set a given theme/color-scheme
      function setTheme(themeName) {
        localStorage.setItem('theme', themeName);
        document.documentElement.className = themeName;
      }

      // function to toggle between light and dark theme
      function toggleTheme() {
        if (localStorage.getItem('theme') === 'theme-dark') {
          setTheme('theme-light');
        } else {
          setTheme('theme-dark');
        }
      }

      // Immediately invoked function to set the theme on initial load
      (function () {
        if (localStorage.getItem('theme') === 'theme-light') {
          setTheme('theme-light');
        } else {
          setTheme('theme-dark');
        }
      })();
      

      // ---------------------------

      // toggle menu
      var menu_off = 1
      
      function toggleMenu() {
	let menu = document.querySelector('.side-menu');
	let menu_list = document.querySelector('.side-menu-content');
	let toggle = document.querySelector('.toggle');

	let inactive_color = getComputedStyle(document.body)
	    .getPropertyValue('--color-background');

	let active_color = getComputedStyle(document.body)
	    .getPropertyValue('--color-primary');	
		
	if (menu_off) {
	  // activate menu
	  toggle.style.backgroundColor = active_color;
	  menu.style.width = '170px';
	  menu_list.style.display = 'block';
	  menu_off = 0;
	} else {
	  // de-activate menu
	  toggle.style.backgroundColor = inactive_color;
	  menu.style.width = '60px';	  
	  menu_list.style.display = 'none';
	  menu_off = 1;
	}
      }

set_sections();
hide_sections();
</script>
</div>
</body>
</html>

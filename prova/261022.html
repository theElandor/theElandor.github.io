<!doctype html>
<html lang="en">
<head>
<title>Grammatiche formali, 26/10/22</title>
<!-- 2022-10-29 Sat 17:17 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Matteo Lugli">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style>
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<script>
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script><link rel="stylesheet" type="text/css" href="html_style.css" />
<style>.container{padding-left: 70px; padding-right: 70px;}</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-12"><h1 class="title">Grammatiche formali, 26/10/22</h1>
<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Table of contents</h2>
<div class="outline-text-2" id="text-">
<ol class="org-ol">
<li><a href="#sec-1">Introduzione</a>
</li>
<li><a href="#sec-2">Parse Tree</a>
</li>
<li><a href="#sec-3">Ambiguità di una Grammatica</a>
</li>
<li><a href="#sec-4">Derivazioni canoniche</a>
</li>
<li><a href="#sec-5">Altri problemi</a>
</li>
<li><a href="#sec-6">Esercizi svolti</a>
<ul class="org-ul">
<li><a href="#sec-6-1">Esercizio 1</a>
<ul class="org-ul">
<li><a href="#sec-6-1-1">Parte 1</a>
</li>
<li><a href="#sec-6-1-2">Parte 2</a>
</li>
</ul>
</li>
<li><a href="#sec-6-2">Esercizio 2</a>
</li>
</ul>
</li>
</ol>
<hr >
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduzione</h2>
<div class="outline-text-2" id="text-1">
<p>
Per prima cosa, viene introdotto il concetto di <b>grammatiche equivalenti</b>:
</p>
<blockquote>
<p>
\(\blacktriangleright\) Due grammatiche sono equivalenti se generano 
lo stesso insieme di stringhe, quindi se definiscono lo stesso linguaggio.
</p>
</blockquote>
<p>
Lo scopo del programmatore è quindi quello di scegliere una
grammatica che possa <code>agevolare</code> il compito del parser di 
interpretare le sequenze di token.
Esempio di grammatiche equivalenti: \(\downarrow\)
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> G1</h3>
<div class="outline-text-3" id="text-1-1">
\begin{equation}
E \rightarrow E+E|E\times E \\
E \rightarrow (E)|number
\end{equation}
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> G2</h3>
<div class="outline-text-3" id="text-1-2">
\begin{aligned}
 & E \rightarrow E+T | T \\
 & T \rightarrow T \times F | F \\
 & F \rightarrow number | (E)
\end{aligned}

<p>
Per rendersene conto, basta fare delle prove semplici, ad
esempio convertire \(num \times (num + num)\)
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Parse Tree</h2>
<div class="outline-text-2" id="text-2">
<p>
Il Parse Tree è una struttura dati che descrive il processo
di derivazione che porta alla stringa finale, come quello
in figura \(\downarrow\)
<img src="./tree.png" class="img-responsive" alt="tree.png">
</p>

<p>
Una <b>visita DFS <code>in order</code></b> permette di "leggere" la sequenza
finale di interesse, le cui parti sono situate nelle foglie dell'albero.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Ambiguità di una Grammatica</h2>
<div class="outline-text-2" id="text-3">
<p>
Diversi processi di derivazione (usando una stessa grammatica)
possono portare alla costruizione di Parse Tree differenti. In questo
caso, la grammatica è detta <b>ambigua</b>.
</p>
<blockquote>
<p>
\(\blacktriangleright\) Una grammatica si dice <b>ambigua</b> se almeno
una frase ammette diversi Parse Tree.
</p>
</blockquote>
<p>
Questo non sarebbe un problema per quanto visto fino ad
adesso, ma bisogna pensare al parse tree come <i>un'anticipazione del significato della stringa</i>".
Ciò significa che alcuni alberi potrebbero risultare "sbagliati" dal 
punto di vista interpretativo. Ad esempio: \(\downarrow\)
<img src="./ambig.png" class="img-responsive" alt="ambig.png">
</p>

\begin{equation}
num \times num + num
\end{equation}
<p>
in questo caso, l'albero di sinistra "sembra scorretto", perchè
suggerisce l'esecuzione dell'addizione (che si trova nel blocco più basso)
rispetto all'esecuzione della moltiplicazione, che invece ha la precedenza.
Una grammatica non ambigua, al contrario, forza l'esistenza di una sola
derivazione, quindi la costruzione di un solo albero!
</p>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Derivazioni canoniche</h2>
<div class="outline-text-2" id="text-4">
<p>
Un processo utile per aiutare la "regolarizzazione" di una grammatica, 
è quello di definire una specifica derivazione da utilizzare.
Solitamente si hanno 2 scelte:
</p>
<ol class="org-ol">
<li>Derivazione <b>canonica destra</b>;
</li>
<li>Derivazione <b>canonica sinistra</b>;
</li>
</ol>
<blockquote>
<p>
\(\blacktriangleright\) Una derivazione canonica destra/sinistra prevede ad ogni passo la riscrittura del simbolo
non terminale più a destra/sinistra
</p>
</blockquote>
<p>
In questo modo, dato un parse tree, si riesce sempre a risalire al
processo di derivazione utilizzato!
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Altri problemi</h2>
<div class="outline-text-2" id="text-5">
<p>
Altri problemi che possono ostacolare il ruolo del parser sono:
</p>
<ul class="org-ul">
<li>Cicli: \(A \overset{+} \Rightarrow A\);
</li>
<li>Left recursion: \(A \overset{+} \Rightarrow A\alpha\);
</li>
<li>Prefissi comuni; \(A \rightarrow \alpha\beta_{1}\) e \(A \rightarrow \alpha\beta_{2}\) 
</li>
</ul>
<hr >

<figure>
<p><img src="./problems.png" class="img-responsive" alt="problems.png">
</p>
</figure>
<hr >
<p>
I problemi riguardo le <code>precedenze di operatore</code> prima sollevati
possono essere risolti aggiungendo dei "layer" alla grammatica,
secondo i livelli di precedenza. Ad esempio:
</p>
\begin{aligned}
& E \rightarrow E + T \ | \ T \\
& T \rightarrow T \times F \ | \  F \\
& F \rightarrow number \ |\  (E) \\
\end{aligned}

<p>
Per ottenere la solita espressione \(num \times num + num\) si
può usare soltanto una specifica serie di derivazioni, che oltretutto
produce un risultato facilmente interpretabile dal parser. Se si 
prova a seguire un'altro ordine, ci si blocca subito!
<img src="./cases.png" class="img-responsive" alt="cases.png">
</p>

<p>
Se usassimo \(T \rightarrow F \times T\) invece di \(T \rightarrow T \times F\),
per ottenere \(num \times num \times num\), si otterrebbe un'albero come
in figura, che suggerisce un'<code>associatività delle operazioni a destra</code>,
quando invece nell'aritmetica si svolgono prima le operazioni sulla
sinistra quando esse sono sullo stesso livello di priorità.
<img src="./inversion.png" class="img-responsive" alt="inversion.png">
</p>
<hr >
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Esercizi svolti</h2>
<div class="outline-text-2" id="text-6">
<p>
Entrambe le consegne degli esercizi si possono trovare a <b>slide 38</b> del
blocco sulle grammatiche.
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Esercizio 1</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Fornire una grammatica libera per l’insieme delle stringhe costituite da
  parentesi correttamente bilanciate;
</p>
\begin{equation}
S \rightarrow (S)S \ | \  \epsilon
\end{equation}

<p>
E' interessante notare il fatto che non esiste alcun automa che possa
riconoscere questo tipo di linguaggio, dato che richiede la memorizzazione
di sequenze di parentesi.
</p>

<p>
Forniamo ora una <b>dimostrazione formale</b> per induzione, suddivisa in 2 parti.
</p>
<hr >
</div>
<div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1"><span class="section-number-4">6.1.1</span> Parte 1</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
Si consideri una generica stringa \(f\) di caratteri non terminali e un generico numero di passaggi di derivazione \(n\).
</p>
<ul class="org-ul">
<li><b>Hp</b>: \(f\) generabile a partire da S;
</li>
<li><b>Th</b>: \(f\) è bilanciata;
</li>
</ul>
<p>
<code>Ipotesi Induttiva</code>: Se si considera n = 1, l'unica stringa di caratteri non terminali
generabile è la stringa vuota, che sicuramente è anche bilanciata.<br >
<code>Induzione</code>: supponiamo che tutte le derivazioni con meno di n passaggi
siano in grado di generare stringhe di parentesi bilanciate. (Se può aiutare, 
al primo passaggio si può considerare \(n=2\), e come abbiamo dimostrato la base induttiva
è vera per \(n=1\)).
Scriviamo quindi una generica derivazione in \(n\) passaggi:
</p>
\begin{equation}
S \rightarrow S_{1}(S_{2}) \rightarrow ...x(S_{2}) \rightarrow ...x(y)
\end{equation}
<p>
dove \(x\) e \(y\) indicano delle sequenze di caratteri <b>terminali</b>.
Dato che l'intera produzione è lunga \(n\) passaggi, si sa per certo
che le derivazioni che hanno portato alla riscrittura di \(S_{1}\) in \(x\)
e di \(S_{2}\) in \(y\) sono lunghe <i>meno</i> di n passaggi.
Quindi per ipotesi induttiva le stringhe \(x\) e \(y\) saranno bilanciate.
Ma se \(x\) e \(y\) sono bilanciate, allora anche \(x(y)\) lo è \(\square\).
</p>
<hr >
</div>
</div>
<div id="outline-container-sec-6-1-2" class="outline-4">
<h4 id="sec-6-1-2"><span class="section-number-4">6.1.2</span> Parte 2</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
Nella seconda parte della dimostrazione si vuole dimostrare l'inverso,
quindi: 
</p>
<ul class="org-ul">
<li><b>Hp</b>: \(f\) è una stringa costituita da parentesi bilanciate;
</li>
<li><b>Th</b>: \(f\) è sicuramente ottenibile a partire da S;
</li>
</ul>
<p>
<code>Ipotesi Induttiva</code>: se si considera una stringa di lunghezza pari a \(0\),
essa è sicuramente bilanciata, e di sicuro è ottenibile da S dato che si tratta 
di &epsilon;.<br >
<code>Passo induttivo</code>: si consideri una generica stringa \(w\) lunga \(2n\) caratteri (
si usa \(2n\) perchè le parentesi bilanciate sono ovviamente costituite da un numero pari
di parentesi). Presupponiamo che tutte le stringhe di lunghezza minore di \(2n\) siano ottenibili
a partire da \(S\). 
</p>

<p>
Dato che \(w\) è bilanciata, può sicuramente essere riscritta come \(x(y)\), dove
\(x\) e \(y\) sono a loro volta bilanciate e di lunghezza sicuramente minore della lunghezza
totale di \(w\), che è \(2n\). Per ipotesi induttiva esse sono quindi ottenibili a partire da \(S\).
Ma se questo è vero, posso allora scrivere questa produzione:
</p>
\begin{equation}
S \rightarrow S(S) \rightarrow ...x(S) \rightarrow ...x(y)
\end{equation}
<p>
e leggendo soltanto il primo e ultimo termine
</p>
\begin{equation}
S \rightarrow x(y) = w  \  \square
\end{equation}
<hr >
</div>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Esercizio 2</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Fornire una grammatica libera per il linguaggio
  \(L_{1,2}=\{a^nb^{2n} | n>=0\}\)
</p>
\begin{equation}
S \rightarrow aSbb | \epsilon
\end{equation}
<p>
In questo modo, ogni volta che si aggiunge una \(a\) all'inizio, si aggiungono 2 \(b\) alla
fine, creando il linguaggio giusto.
</p>
<hr >
</div>
</div>
</div>
</div></div></div>
<footer id="postamble" class="">
<div><p class="author">Author: Matteo Lugli</p>
<p class="date">Created: 2022-10-29 Sat 17:17</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="http://orgmode.org">Org-mode</a> 9.1.9)</p>
</div>
</footer>
</body>
</html>

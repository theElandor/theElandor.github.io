<!doctype html>
<html lang="en">
<head>
<title><b>Parsing 1, 27/10/22</b></title>
<!-- 2022-10-28 Fri 14:25 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Matteo Lugli">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style>
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<script>
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script><link rel="stylesheet" type="text/css" href="html_style.css" />
<style>.container{padding-left: 80px; padding-right: 80px;}</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-12"><h1 class="title"><b>Parsing 1, 27/10/22</b></h1>
<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Table of contents</h2>
<div class="outline-text-2" id="text-">
<ol class="org-ol">
<li><a href="#sec-1">Parser a discesa ricorsiva</a>
<ul class="org-ul">
<li><a href="#sec-1-1">Parser non deterministico</a>
</li>
<li><a href="#sec-1-2">Parser deterministico</a>
</li>
</ul>
</li>
<li><a href="#sec-2">Left recursion e cicli</a>
<ul class="org-ul">
<li><a href="#sec-2-1">Eliminazione left recursion(esempio)</a>
</li>
<li><a href="#sec-2-2">Backward Production</a>
</li>
</ul>
</li>
<li><a href="#sec-3">Miglioramento di una grammatica (esempio finale)</a>
<ul class="org-ul">
<li><a href="#sec-3-1">Eliminazione B.Production</a>
</li>
<li><a href="#sec-3-2">Eliminazione Left Recursion</a>
</li>
</ul>
</li>
</ol>
<hr >
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Parser a discesa ricorsiva</h2>
<div class="outline-text-2" id="text-1">
<p>
In questo corso si tratteranno principalmente i parser a discesa
ricorsiva, che costruiscono il parse tree a partire dall'assioma
verso il basso, controllando se la stringa generata corrisponde 
con l'input preso dal lexer.
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Parser non deterministico</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Pensando ad un algoritmo non deterministico, che quindi ad ogni 
passo sceglie la produzione più "adatta", si potrebbe semplicemente
abbozzare uno pseudo-codice del genere:
</p>
<p class="verse">
for j = 1&#x2026;k do:<br >
&#xa0;&#xa0;if \(X_{j} \in N\) then X<sub>j</sub>()<br >
&#xa0;&#xa0;else:<br >
&#xa0;&#xa0;&#xa0;&#xa0;\(x\) \(\leftarrow\) read()<br >
&#xa0;&#xa0;&#xa0;&#xa0;if X<sub>j</sub> &ne; \(x\) then error()<br >
</p>
<p>
Ad ogni passo, se ci si trova su un carattere <b>terminale</b> si controlla
che esso faccia "matching" con l'input, altrimenti
se ci si trova su un <b>non terminale</b> si richiama ricorsivamente la
procedura sul carattere corrente. Si tenga a mente che in questo 
primo codice <i>non ci si pone il problema di scegliere la produzione giusta,
perchè l'algoritmo è <code>non deterministico</code></i>
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Parser deterministico</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Il passo successivo della progettazione di un parser consiste nel 
cercare di eliminare il non determinismo, pensando ad un algoritmo
che scelga la produzione giusta tra le varie disponibili.
</p>
<hr >

<figure>
<p><img src="./paraser_determ.png" class="img-responsive" alt="paraser_determ.png">
</p>
</figure>
<hr >
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> Esempio:</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Considerando questa grammatica:
</p>
\begin{aligned}
& S \rightarrow aA \\
& A \rightarrow aA | B \\
& B \rightarrow bB | \epsilon
\end{aligned}

<p>
si ottiene il seguente albero di derivazione:
<img src="./parser_esempio.png" class="img-responsive" alt="parser_esempio.png">
</p>
<hr >
<p>
Se si analizzano il codice e la figura, ci si rende conto del seguente problema:
se ad esempio invece di \(A \rightarrow aA\) avessimo usato la produzione \(A \rightarrow Aa\),
allora l'algoritmo cadrebbe in una cascata infinita di chiamate ricorsive. 
Una produzione che da origine a questo fenomeno prende il nome di <b><code>left recursion</code></b>.
Il motivo per cui accade è che il parser analizza sempre il primo carattere prodotto,
ma se questo è un non terminale, allora su di esso verrà applicata una riscrittura per verificarne
la validità &#x2026; \(\rightarrow \infty\)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Left recursion e cicli</h2>
<div class="outline-text-2" id="text-2">
<p>
Per progettare una grammatica in modo efficate, si può pensare
alla scrittura della stessa nel modo più semplice possibile, senza
pensare alla ricaduta in ricorsioni infinite di vario genere.
Solo in un secondo momento è conveniente applicare un processo di 
raffinamento ed eliminazione di ricorsioni infinite.
Negli esempi che seguono, si presuppone che le grammatiche non presentino errori
banali come cicli infiniti, cioè sequenze di derivazioni di questo tipo \(\downarrow\)
</p>
\begin{equation}
A \overset{*} \Rightarrow A
\end{equation}
<p>
Ecco quindi un'esempio di eliminazione di left-recursion:
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Eliminazione left recursion(esempio)</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Si consideri la seguente grammatica:
</p>
\begin{aligned}
& A \rightarrow A\alpha \\ 
& A \rightarrow \beta
\end{aligned}
<p>
come si può notare dalla prima produzione, c'è un problema di left recursion.
Per eliminarla si può applicare uno specifico algoritmo di eliminazione.
In particolare, si riscrive la produzione che presenta left recursion in questo modo \(\downarrow\)
</p>

\begin{cases}
& A \rightarrow \beta_{1}A' | \beta_{2}A' | ... | \beta_{m}A'\\
\\
& A' \rightarrow \alpha_{1}A' | \alpha_{2}A' | ... | \alpha_{t}A' | \epsilon
\end{cases}
<p>
in cui:
</p>
<ul class="org-ul">
<li>\(\beta_{x}\) \(\rightarrow\) stringhe che non hanno left recursion, quindi quelle
che non danno problemi;
</li>
<li>\(\alpha_{x}\) \(\rightarrow\) parte a destra delle stringhe che presentano left
recursion, quindi tutto tranne il carattere non terminale che da problemi;
</li>
</ul>
\begin{aligned}
& A \rightarrow A\alpha \\ 
& A \rightarrow \beta
\end{aligned}

\begin{equation}
\Downarrow
\end{equation}

\begin{align}
& A \rightarrow \beta A' \\
& A' \rightarrow \alpha A' | \epsilon
\end{align}

<p>
Alla fine di questo processo si è sicuri di non avere delle left-recursion,
perchè tutte le produzioni iniziano per un carattere <code>terminale</code>.
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Backward Production</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Per essere sicuri di aver progettato una grammatica valida, è importante anche 
eliminare le <b><code>backward production</code></b>.
Sia \(A_{1}...A_{n}\) un'ordinamento arbitrario dei caratteri non terminali,
</p>
<blockquote>
<p>
\(\blacktriangleright\) si dice <b>backward production</b> una produzione del tipo \(A_{i} \rightarrow A_{j}\) con \(i > j\) nell'ordinamento.
</p>
</blockquote>
<p>
L'algoritmo per l'eliminazione di queste produzioni è più chiaro se spiegato tramite
un'esempio \(\downarrow\)
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Miglioramento di una grammatica (esempio finale)</h2>
<div class="outline-text-2" id="text-3">
<p>
Si consideri la seguente grammatica:
</p>
\begin{align}
& A \rightarrow Bb|a \\
& B \rightarrow Bb|Ac
\end{align}
<p>
Consideriamo l'ordinamento {A<sub>1</sub>, B<sub>2</sub>}.
</p>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Eliminazione B.Production</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Per eliminare le backwards production, per prima cosa ci si posiziona sulla 
produzione problematica, in questo caso la seconda, che può portare indietro
la riscrittura al carattere non terminale A partendo da B.
</p>

<p>
Successivamente si riscrive il carattere non terminale di destinazione (quindi A in questo
caso, che si trova prima di B nell'ordinamento arbitrario che abbiamo scelto) e lo si riscrive
usando le sue stesse produzioni, ottenendo:
</p>

\begin{align}
& A \rightarrow Bb|a \\
& B \rightarrow Bb|Bbc|ac
\end{align}

<p>
ora si è sicuri di non avere nessuna backwards production, e si procede con
l'eliminazione delle left recursion, come spiegato prima.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Eliminazione Left Recursion</h3>
<div class="outline-text-3" id="text-3-2">
\begin{align}
& A \rightarrow Bb|a \\
& B \rightarrow acB' \\
& B' \rightarrow bB'|bcB'|\epsilon
\end{align}
<hr >
</div>
</div>
</div>
</div></div></div>
<footer id="postamble" class="">
<div><p class="author">Author: Matteo Lugli</p>
<p class="date">Created: 2022-10-28 Fri 14:25</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="http://orgmode.org">Org-mode</a> 9.1.9)</p>
</div>
</footer>
</body>
</html>

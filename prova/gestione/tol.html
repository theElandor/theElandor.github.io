<!DOCTYPE html>
<head>
<title> <b>Tolerant Retrieval</b> </title>
<meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="generator" content="Org-mode"><meta name="author" content="Matteo Lugli üêÉ">
<link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@5.2/distr/fira_code.css">
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>
<style>
    .theme-light {
	--color-primary: black;
	--color-background: white;
	--color-text: black;
    }

    .theme-dark {
    
	--color-primary: #23b0ff;
	--color-background: #21202C;
	--color-text: white;
    }
    
    body {
	font-family: 'Fira Code', monospace;
	font-size: 20px;
	background-color: white;
    }

    div#menu {
	position: sticky;
	position: -webkit-sticky;
	top: 5px;
	z-index: 30;
    }

    div#menu button {
	right: 0px;
	position: absolute;
    }
    .src{
        background-color:white;
        color:black;
    }
    p {
	color: var(black);
    }

    h1,h3, h4, h5, a {
	color: var(black);
    }
    h2{
        color:#337ab7;
    }
    h4{
        color:magenta;
    }

    .title{
        text-decoration: underline;
        font-weight:bold;
    }

    nav a {
	color: var(black);
    }

    nav a:hover {
	color: var(black);
	text-decoration: none;
    }

    ul li, ol li {
	color: var(black);
    }

    .collapsible {
        background-color: white;
	border: none;
	text-align: left;
    }
    
    .top-buffer { margin-top: 18px; }

    figcaption { font-size: 15px; }

    footer { 
        text-align: center; 
        background-color: #FFFFEA;
    }

    .observation {
	border-style: solid;
	margin-top: 20px;
	margin-bottom: 20px;
    }

    pre {
	font-size: 20px;
	background-color: black;
	color: white;
	inline-size: 900px;
	overflow: auto;
	word-wrap: normal;
    }
    blockquote {
	border-left: 5px solid var(black);
        background-color: #ffffEA;
        font-size: 20px;
    }
    .MathJax_SVG_Display{
        color:black;
    }

    blockquote p {
	color: var(black);
    }

    /* side-menu stuff */
    .side-menu {
	position: fixed;
	left: 0;
	width: 60px;
	height: 100%;
	z-index: 100;
    }

    .side-menu-content {
	display: none;
	position: absolute;
	top: 60px;
	left: 0px;
	height: 100%;
	/* background-color: var(black); */
	z-index: 100;	
    }

    .side-menu-content ul {
	list-style-type: none;
	position: relative;
	margin-left: 5px;
	width: 100%;
	padding-left: 0px;
    }

    .side-menu-content ul li {
	position: relative;
	padding-top: 5px;
	font-size: 15px;
	padding-left: 0px;
    }

    .side-menu-content ul li a {
	color: var(black);
	text-decoration: none;
	font-weight: bold;
    }

    .toggle {
	position: absolute;
	display: block;
	top: 0;
	left: 0;
	width: 80px;
	height: 60px;
	background: var(white);
    }

    .toggle:hover {
	background: var(black);
    }

    .toggle:before {
	content: '\f0c9';
	font-family: fontAwesome;
	position: absolute;
	width: 100%;
	height: 100%;
	line-height: 60px;
	text-align: center;
	font-size: 24px;
	color: var(black);
    }

    @media (max-width: 1024px) {
	pre {
	    inline-size: 600px;
	}
    }

    @media (max-width: 576px) {
	* {
	    font-size: 10px;
	}

	h1 {
	    font-size: 13px;           
	}

	h2, h3, h4, h5 {
	    font-size: 12px;
	}

	blockquote {
	    font-size: 15px;
	}

	pre, li pre {
	    font-size: 10px;
	    color: white;
	    inline-size: 300px;
	    word-wrap: normal;
	    overflow: auto;
	}

        li pre {
	    inline-size: 250px;
        }

	.toggle {
	    width: 30px;
	}

	.toggle:before {
	    content: '\f0c9';
	    font-family: fontAwesome;
	    position: absolute;
	    width: 100%;
	    height: 100%;
	    line-height: 60px;
	    text-align: center;
	    font-size: 12px;
	    color: var(black);
	}	
    }


</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="content" class="container">

<div class="row top-buffer"> </div>

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><h1 class="title"><b>Tolerant Retrieval</b></h1>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->
<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><hr style="border: 1px solid #FFFFFF" />   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->
<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-" style="text-decoration: underline">  Info &triangledown;</h2>
</button><div class='sec- collapsible-content'>
<p>
Appunti presi dalle lezioni dell'anno 2021. 
</p>
</div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-" style="text-decoration: underline">  Mappa concettuale &triangledown;</h2>
</button><div class='sec- collapsible-content'>
<p>

<div class="row top-buffer"> </div>
<img src="./tol_map.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>
</div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-1" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-1" style="text-decoration: underline"> 1 Introduzione &triangledown;</h2>
</button><div class='sec-1 collapsible-content'>
<p>
In generale, la <b>Tolerant Retrieval</b> si occupa della ricerca
di documenti nei casi in cui le query fornite dagli utenti
contengano parole che non sono presenti nell'indice.
I tre casi presi in analisi sono <b>wildcard queries</b>, 
<b>spelling correction</b> e <b>Soundex</b>. 
</p>
</div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-2" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-2" style="text-decoration: underline"> 2 Wildcard queries &triangledown;</h2>
</button><div class='sec-2 collapsible-content'>
<p>
Per risolvere le wildcard queries si possono usare diversi metodi:
</p>
<ul class="org-ul">
<li><p>
<b>Intersection of results</b>;
</p>
</li>
<li><p>
<b>Permutation Index</b>;
</p>
</li>
<li><p>
<b>Q-grams Index</b>;
</p>
</li>
</ul>
<p>
A seguire i dettagli.
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-2-1" nil> 2.1 Prefix &triangledown;</h3>
</button><div class='sec-2-1 collapsible-content'>
<p>
Le Prefix Query sono del tipo <i>mon*</i>.
</p>

<p>
Queste sono le meno problematiche, perch√® la ricerca pu√≤ essere
fatta semplicemente nell'indice originario. Nello specifico, si
effettua una <b>ricerca binaria</b> per trovare la prima parola che matcha,
per poi scendere nell'indice ordinato.
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-2-2" nil> 2.2 Postfix &triangledown;</h3>
</button><div class='sec-2-2 collapsible-content'>
<p>
Le Postfix Query sono del tipo  <i>*mon</i>. 
</p>

<p>
La soluzione pi√πsemplice √® quella di mantenere in memoria un <b>indice invertito</b>:
in questo modo si pu√≤ ribaltare la query e effettuare una ricerca
identica a quella per una prefix query.
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-2-3" nil> 2.3 Middle &triangledown;</h3>
</button><div class='sec-2-3 collapsible-content'>
<p>
Query tipo <i>m*nchen</i>.
</p>

<p>
In questo caso si possono adottare 2 soluzioni:
</p>
<ul class="org-ul">
<li><p>
<b>Intersection</b>: facendo riferimento all'esempio, si fa una
ricerca su <i>m*</i> e <i>*nchen</i> e si intersecano i set di risultati.
</p>
</li>
<li><p>
<b>Permutation Index</b>: si mantiene un'indice aggiuntivo che
memorizza tutte le permutazioni di ogni parola nel dizionario,
in cui ogni permutazione punta alla parola originale.
"$" √® semplicemente un <i>carattere di terminazione</i> aggiuntivo
che viene memorizzato nell'indice insieme al resto della parola.

<div class="row top-buffer"> </div>
<img src="./tol1.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

Per processare una query si seguono poi le seguenti regole:

<div class="row top-buffer"> </div>
<img src="./tol2.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>
  
Per la ricerca ad esempio di <i>hel*o</i>, si cerca <b>o$hel*</b>
Il segreto √® cercare di ricondursi sempre ad una <b>postfix query</b>,
non curandosi dell'ordine assoluto dei termini, ma soltanto di quello
relativo.
Il problema di questo approccio √® la dispendiosit√† in termini di 
<i>occupazione di memoria</i>, che viene quadruplicata rispetto all'uso 
di un'indice normale.
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-2-4" nil> 2.4 <b>q-grams</b> &triangledown;</h3>
</button><div class='sec-2-4 collapsible-content'>
<blockquote>
<ul class="org-ul">
<li><p>
<b>q-gramma</b>: sequenza di q caratteri della stringa a cui 
sono stati aggiunti \(q-1\) "#" all'inizio e \(q-1\) "$" 
alla fine.
</p>
</li>
</ul>
</blockquote>
<p>
Esempio per q = 3, per la parola "vacations":
</p>

<p>
{##v, #va, vac, aca, cat, ati, tio, ion, ons, ns$, s$$}
</p>

<p>
Quindi in generale da una stringa lunga \(L\) si ottengono
\(L+q-1\) q-grammi.
Data questa definizione, l'approccio per creare una struttura
dati che possa permettere di effettuare Middle Queries √® il seguente:
</p>
<ul class="org-ul">
<li><p>
Generare tutti i q-grammi di ogni parola del dizionario;
</p>
</li>
<li><p>
Creare un'indice (<b>q-gram index</b>) in cui ogni q-gramma
punta alle parole da cui pu√≤ essere estratto.
</p>
</li>
</ul>
<p>
Esempio di un <b>bi-gram index</b> \(\downarrow\)

<div class="row top-buffer"> </div>
<img src="./tol3.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

Ora rimane da capire come sfruttare questo indice per
processare le query. Si pu√≤ procedere ad esempio in questo
modo: <i>mon*</i> \(\rightarrow\) <i>#m AND mo AND on</i>. Vengono
per√≤ generati anche dei <b>falsi positivi</b> come "MOON", 
quindi dopo il processing bisogna effettuare anche 
un'operazione di "filtraggio" (<b>postfiltering</b>).
</p>

<blockquote>
<p>
L'uso del q-gram index richiede un minor uso di memoria, 
dall'altro lato il permuterm index non richiede il post-filtering.
</p>
</blockquote>
</div>
</div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->


<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-3" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-3" style="text-decoration: underline"> 3 Spelling correction &triangledown;</h2>
</button><div class='sec-3 collapsible-content'>
<p>
Usata per correggere i documenti inseriti nell'indice (raramente)
o pi√π spesso per correggere le query inserite dall'utente.
Solitamente non viene corretto direttamente il documento, in pratica
si cercano di correggere le parole che vengono salvate nell'index.
</p>
</div>
<div id="outline-container-sec-3-1" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-3-1" nil> 3.1 Isolated Word Correction &triangledown;</h3>
</button><div class='sec-3-1 collapsible-content'>
<p>
Per questo approccio, prima di procedere serve definire 
"da dove vengono prese" le parole corrette. Le due alternative
sono:
</p>
<ul class="org-ul">
<li><p>
Un generico <b>dizionario</b> linguistico; 
</p>
</li>
<li><p>
Il lessico estratto dai <b>documenti indicizzati</b>;
</p>
</li>
</ul>
<p>
In generale quindi l'idea √® quella di calcolare un valore
di <b>distanza</b> (inverso della similarit√†/similitudine) tra 
la parola da correggere e le possibili correzioni, per capire
quali sono le pi√π plausibili. Esistono diversi modi per
fare questo calcolo:
</p>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4"><button type="button" class="collapsible">
<h4 id="sec-3-1-1" nil> 3.1.1 <b>Edit distance</b> &triangledown;</h4>
</button><div class='sec-3-1-1 collapsible-content'>
<blockquote>
<p>
<b>Edit distance</b> \(\rightarrow\) numero minimo di operazioni
da effettuare per convertire una parola in un'altra.
</p>
</blockquote>
<p>
Le operazioni consentite per convertire una parola in un'altra
sono:
</p>
<ul class="org-ul">
<li><p>
Modello <b>Levenshtein</b>: Insert, Delete, Replace;
</p>
</li>
<li><p>
Modello <b>Damerau-Levenshtein</b>: Insert, Delete, Replace, <i>Transposition</i>;
</p>
</li>
</ul>
<p>
Per esempio:
</p>
\begin{align}
& distance(dof, dog)=1 \\
& distance(cat, act)=2 \\
& distance(cat, dog)=3 \\
\end{align}
<p>
invece considerando anche la trasposizione
</p>
\begin{align}
& distance(cat, act)=1 \\
\end{align}
<p>
perch√® basta spostare la "c" dopo la "a".
L'algoritmo che calcola questa distanza fa uso della <b>DP</b>,
seguendo questi passi:
</p>
<ul class="org-ul">
<li><p>
si <b>inizializzano</b> la prima riga e la prima colonna come
in figura;
</p>
</li>
<li><p>
per riempire la tabella, quindi ad un generico passo:
</p>
<ul class="org-ul">
<li><p>
se rosso == azzurro \(\rightarrow\) blu :=giallo;
</p>
</li>
<li><p>
altrimenti \(\rightarrow\) blu := 1 + min(giallo, verde);
</p>
</li>
</ul>
</li>
<li><p>
il risultato finale √® l'ultimo elemento in basso a destra;
</p>
</li>
</ul>
<p>

<div class="row top-buffer"> </div>
<img src="./tol4.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>
<ul class="org-ul">
<li><p>
<b>Space complexity</b>: O(n), basta memorizzare la colonna e la riga 
precedenti.
</p>
</li>
<li><p>
<b>Time complexity</b>: O(\(n^2\)), in quanto bisogna riempire l'intera tabella.
</p>
</li>
</ul>
<p>
Esiste una variante di questo algoritmo che fa uso di 
una matrice aggiuntiva in cui sono memorizzati pesi per ogni
coppia di lettere, in base alla loro distanza effettiva sulla tastiera.
Ogni volta che si aggiungeva 1 nell'algoritmo, ora si aggiunge il peso
corrispondente ai due caratteri presi in esame in quel momento.
In questo modo alla fine si ottiene una distanza "pesata" che considera
anche la probabilit√† di aver premuto un tasto rispetto ad un altro (ad esempio, 
il peso della coppia \(m,n\) sar√† sicuramente <b>minore</b> del peso di \(m,q\), in quanto
la sostituzione di \(m\) con \(n\) "costa meno" rispetto alla sostituzione di \(m\) con \(q\)).
</p>

<p>
Riassumendo: 
</p>

<p>
quando un'utente digita una query, si calcolano le edit distance
per tutti i termini nel vocabolario e si ritorna la parola con
edit distance minore. E' comunque un'approccio <b>lento</b> dato che deve
calcolare l'edit distance per molti termini.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4"><button type="button" class="collapsible">
<h4 id="sec-3-1-2" nil> 3.1.2 <b>Q-gram overlap</b> &triangledown;</h4>
</button><div class='sec-3-1-2 collapsible-content'>
<p>
L'idea √® quella di calcolare i q-grammi della parola da correggere, per poi
usare il <b>q-gram index</b> per trovare tutte le parole del lessico che condividono
almeno 1 q-grama con la parola da correggere. Alla fine si mostrano
soltanto le parole che hanno il <b>maggior numero di qgrammi comuni</b>.

<div class="row top-buffer"> </div>
<img src="./tol5.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

In realt√†, invece che un semplice conteggio degli elementi comuni, si usa
il <b>Jaccard Coefficient</b>, che misura "quanto due insiemi sono simili
in base a quanti elementi hanno in comune."
</p>
\begin{equation}
\frac{|X \cap Y|}{|X \cup Y|}
\end{equation}
<p>
in cui: 
</p>
<ul class="org-ul">
<li><p>
X \(\rightarrow\) q-grammi della parola da correggere;
</p>
</li>
<li><p>
Y \(\rightarrow\) q-grammi della parola del lexicon;
</p>
</li>
</ul>
<p>
Il numeratore quindi rappresenta il <b>numero di qgrammi comuni</b> mentre
il denominatore rappresenta il <b>numero di qgrammi distinti totali</b>.
Rispetto all'edit distance, questo metodo consiste in un calcolo
molto pi√π semplice, lineare rispetto al numero di parole.
</p>

<p>
Se le liste di parole associate ai qgrammi sono mantenute in ordine alfabetico,
basta uno scan lineare per trovare le parole che condividono \(x\) qgrammi.
</p>

<p>

<div class="row top-buffer"> </div>
<img src="./overlap.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>
  
</p>
</div>
</div>


<div id="outline-container-sec-3-1-3" class="outline-4"><button type="button" class="collapsible">
<h4 id="sec-3-1-3" nil> 3.1.3 <b>Advanced Q-gram filtering</b> &triangledown;</h4>
</button><div class='sec-3-1-3 collapsible-content'>
<p>
Esistono alcuni <b>filtri</b> da applicare a priori alla parola da correggere e alle
parole nel dizionario per evitare di calcolare l'edit distance. 
(Si cerca di calcolare l'edit distance per meno parole possibili).
</p>
<ul class="org-ul">
<li><p>
<b>Length Filter</b>: si parte dal presupposto che se la differenza di lunghezza √®
pari a \(p\), allora l'edit distance della coppia di parole non pu√≤ essere minore di
\(p\).
</p>
<blockquote>
<ul class="org-ul">
<li><p>
Due stringhe \(S1\) e \(S2\) se hanno <b>edit distance</b> <= \(k\) allora abs(len(\(S1\))-len(\(S2\))) <= \(k\)
</p>
</li>
</ul>
</blockquote>
</li>
<li><p>
<b>Count Filter</b>: l'idea √® che <i>parole simili hanno in comune molti qgrammi</i>
</p>
<blockquote>
<ul class="org-ul">
<li><p>
Due stringhe \(S1\) e \(S2\) che hanno <b>edit distance</b> <= \(k\) hanno almeno [max(len(\(S1\))),(len(\(S2\)))+ \(q\) - 1]-\(kq\) qgrammi.
</p>
</li>
</ul>
</blockquote>
</li>

<li><p>
<b>Position Filter</b>: si pensi alle seguenti sequenze di caratteri:
</p>
<ul class="org-ul">
<li><p>
aabbzzaacczz
</p>
</li>
<li><p>
aacczzaabbzz
</p>
</li>
</ul>
<p>
Queste generano (per \(q = 3\)) gli stessi identici q-grammi, ma in ordine diverso.
Tuttavia queste parole hanno edit distance molto alta, pari a 4. L'idea del position
filter √® quella di <b>memorizzare le posizioni dei q-grammi</b>, e non considerare nel 
<b>count filter</b> i q-grammi che distano <b>pi√π di k posizioni</b>.  
</p>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3"><button type="button" class="collapsible">
<h3 id="sec-3-2" nil> 3.2 Context-sensitive &triangledown;</h3>
</button></div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><div id="outline-container-sec-4" class="outline-2"><button type="button" class="collapsible">
<h2 id="sec-4" style="text-decoration: underline"> 4 Soundex &triangledown;</h2>
</button><div class='sec-4 collapsible-content'>
<p>
Questo algoritmo serve per indicizzare le parole in base a "<i>come suonano</i>",
in modo da creare degli <b>insiemi</b> di parole <b>omofoniche</b>.
Ad alto livello, gli step da seguire sono i seguenti:
</p>
<ul class="org-ul">
<li><p>
Trasformare ogni token in una sequenza di 4 caratteri tramite l'algoritmo;
</p>
</li>
<li><p>
Costruire un index usando queste forme ridotte;
</p>
</li>
<li><p>
Trasformare i termini della query;
</p>
</li>
</ul>
<p>
Il processo di <b>trasformazione</b> in sequenze di 4 caratteri √® il seguente:

<div class="row top-buffer"> </div>
<img src="./soundex1.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>
<hr >
<p>

<div class="row top-buffer"> </div>
<img src="./s2.png"class="img-responsive"style="display: block; margin-left: auto; margin-right: auto;">
<div class="row top-buffer"> </div>

</p>
</div>
</div>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->

<div class="row top-buffer"> </div>

<div class="row top-buffer"> </div>

<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><hr style="border: 1px solid #FFFFFF" />   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->
<div class="row">
   <div class="col-xs-1"></div>
   <div class="col-xs-10"><footer id="postamble">
<div>
<p class="author"><b>Author</b>: Matteo Lugli üêÉ</p><p class="email"><b>Email</b>: <a href="mailto:matteolugli18@gmail.com">matteolugli18@gmail.com</a></p><p class="date"><b>Created</b>: 2023-06-14 mer 19:48</p>
</div>
</footer>
   </div>
   <div class="col-xs-1"></div>
</div> <!-- end row -->
<div class="row top-buffer"> </div>

<div class="row top-buffer"> </div>

<div class="row top-buffer"> </div>
<script>

      function set_sections() {
	// -- Deal with the hiding/showing of the various sections
	var buttons = document.getElementsByClassName('collapsible');

	for (var i = 0; i < buttons.length; i++) {
	  buttons[i].addEventListener('click', function() {
	    var content = this.parentElement;
	    divs = content.getElementsByTagName('div');
	    for (var j = 0; j < divs.length; j++) {
	      if (divs[j].style.display === '' || divs[j].style.display === 'block') {
		divs[j].style.display = 'none';
	      } else {
		divs[j].style.display = 'block';
	      }
	    }
	  });
	}
      }

      function hide_sections() {
	// -- Deal with the hiding/showing of the various sections
	var buttons = document.getElementsByClassName('collapsible');
	var sections_to_not_hide = ['Lecture Info', 'Overview', 'Basic Info', 'Informazioni Lezione', 'Table of Contents', 'Informazioni', 'Lecture Summary']

	for (var i = 0; i < buttons.length; i++) {
	  // -- Check which sections to hide initially
	  html_elem = buttons[i].getElementsByTagName('h2').length > 0 ?
	    buttons[i].getElementsByTagName('h2')[0] :
	    buttons[i].getElementsByTagName('h3').length > 0 ?
	    buttons[i].getElementsByTagName('h3')[0] :
	    buttons[i].getElementsByTagName('h4')[0];

	  var hide_section = true;

	  for (var h = 0; h < sections_to_not_hide.length; h++) {
	    if (html_elem.innerHTML.includes(sections_to_not_hide[h])) {
	      hide_section = false;
	    }
	  }

	  if (hide_section) {
	    divs = buttons[i].parentElement.getElementsByTagName('div');

	    for (var j = 0; j < divs.length; j++) {
	      divs[j].style.display =
		divs[j].style.display === '' || divs[j].style.display === 'block' ?
		divs[j].style.display = 'none' :
		divs[j].style.display = 'block';
	    }
	  }    
	}
      }

      // ---------------------------

      // function to set a given theme/color-scheme
      function setTheme(themeName) {
        localStorage.setItem('theme', themeName);
        document.documentElement.className = themeName;
      }

      // function to toggle between light and dark theme
      function toggleTheme() {
        if (localStorage.getItem('theme') === 'theme-dark') {
          setTheme('theme-light');
        } else {
          setTheme('theme-dark');
        }
      }

      // Immediately invoked function to set the theme on initial load
      (function () {
        if (localStorage.getItem('theme') === 'theme-light') {
          setTheme('theme-light');
        } else {
          setTheme('theme-dark');
        }
      })();
      

      // ---------------------------

      // toggle menu
      var menu_off = 1
      
      function toggleMenu() {
	let menu = document.querySelector('.side-menu');
	let menu_list = document.querySelector('.side-menu-content');
	let toggle = document.querySelector('.toggle');

	let inactive_color = getComputedStyle(document.body)
	    .getPropertyValue('--color-background');

	let active_color = getComputedStyle(document.body)
	    .getPropertyValue('--color-primary');	
		
	if (menu_off) {
	  // activate menu
	  toggle.style.backgroundColor = active_color;
	  menu.style.width = '170px';
	  menu_list.style.display = 'block';
	  menu_off = 0;
	} else {
	  // de-activate menu
	  toggle.style.backgroundColor = inactive_color;
	  menu.style.width = '60px';	  
	  menu_list.style.display = 'none';
	  menu_off = 1;
	}
      }

set_sections();
hide_sections();
</script>
</div>
</body>
</html>

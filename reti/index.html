<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Protocolli e architetture di rete ITA-(2022/2023) :: ML</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="protocolli e architetture di rete" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/reti/" />




<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/blue.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon" href="/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="/img/favicon/blue.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Protocolli e architetture di rete ITA-(2022/2023)">
<meta property="og:description" content="protocolli e architetture di rete" />
<meta property="og:url" content="/reti/" />
<meta property="og:site_name" content="ML" />

  
    <meta property="og:image" content="/img/favicon/blue.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2022-12-29 12:57:40 &#43;0100 CET" />












</head>
<body class="blue">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Home
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/htb">HTB</a></li>
        
      
      
        <ul class="menu__sub-inner">
          <li class="menu__sub-inner-more-trigger">Uni-Notes ▾</li>

          <ul class="menu__sub-inner-more hidden">
            
              
                <li><a href="/gestione">Inform. Retrieval</a></li>
              
            
              
                <li><a href="/compilatori">Linguaggi e Compilatori</a></li>
              
            
              
                <li><a href="/ml">Machine Learning and Deep Learning</a></li>
              
            
              
                <li><a href="/reti">Reti</a></li>
              
            
          </ul>
        </ul>
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/htb">HTB</a></li>
      
    
      
        <li><a href="/gestione">Inform. Retrieval</a></li>
      
    
      
        <li><a href="/compilatori">Linguaggi e Compilatori</a></li>
      
    
      
        <li><a href="/ml">Machine Learning and Deep Learning</a></li>
      
    
      
        <li><a href="/reti">Reti</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/reti/">Protocolli e architetture di rete ITA-(2022/2023)</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2022-12-29
        
      </span>
    
    
    
  </div>

  
  


  

  <div class="post-content"><div>
        
  <figure class="left" >
    <img src="/ox-hugo/internet.jpeg"   />
    
  </figure>


<h2 id="cosa-posso-trovare-qui"><em>Cosa posso trovare qui?</em><a href="#cosa-posso-trovare-qui" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Questa pagina (in italiano) contiene i miei appunti del corso di
&ldquo;Protocolli e architetture di rete&rdquo; del corso triennale di informatica
di Unimore.
Verranno quindi riportati gli approfondimenti/chiarimenti che vengono
fatti durante le lezioni. Il materiale include i write-up delle esperienze
fatte in laboratorio.</p>
<p>→ Link per accedere al <code>materiale didattico</code>:</p>
<p>2022/2023 &ndash;&gt; <a href="https://weblab.ing.unimore.it/protocolli/2223">https://weblab.ing.unimore.it/protocolli/2223</a></p>
<p>2021/2022 &ndash;&gt; <a href="https://weblab.ing.unimore.it/protocolli/2122/">https://weblab.ing.unimore.it/protocolli/2122/</a></p>
<p>Le credenziali per accedere al materiale di quest&rsquo;anno sono:</p>
<ul>
<li><strong>username</strong>: PAR2223</li>
<li><strong>password</strong>: Kaw8Meir</li>
</ul>
<p>Le credenziali per accedere al materiale dell&rsquo;anno scorso sono:</p>
<ul>
<li><strong>username</strong>: PAR2122</li>
<li><strong>password</strong>: Enae3pie</li>
</ul>
<h2 id="troubleshooting"><em>Troubleshooting</em><a href="#troubleshooting" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Se la pagina non carica correttamente i contenuti in latec, basta <code>ricaricare</code> la pagina
una o al massimo un paio di volte. Questo problema può essere legato alla grande
quantità di testo e immagini presenti in questa sezione.</p>
<hr>
<h2 id="table-of-contents">TABLE OF CONTENTS<a href="#table-of-contents" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li><a href="#metodi-di-comunicazione">METODI DI COMUNICAZIONE</a></li>
<li><a href="#protocollo-tcp-ip">PROTOCOLLO TCP/IP</a></li>
<li><a href="#htn--introduzione">(HTN) INTRODUZIONE</a></li>
<li><a href="#htn--lan-e-ethernet">(HTN) LAN e ETHERNET</a></li>
<li><a href="#htn--interconnessioni-di-rete-e-accesso-a-internet">(HTN) INTERCONNESSIONI DI RETE E ACCESSO A INTERNET</a></li>
<li><a href="#vlan">VLAN</a></li>
<li><a href="#ip--livello-ip">(IP) Livello IP</a></li>
<li><a href="#ip--subnetting">(IP) Subnetting</a></li>
<li><a href="#ip--ip-routing">(IP) Ip routing</a></li>
<li><a href="#bgp">BGP</a></li>
<li><a href="#tcp">(TCP)</a></li>
<li><a href="#dns">DNS</a></li>
<li><a href="#dhcp">DHCP</a></li>
<li><a href="#security">Security</a></li>
<li><a href="#email">Email</a></li>
<li><a href="#lab-6-10">Lab 6-10</a></li>
<li><a href="#lab-20-10">Lab 20-10</a></li>
<li><a href="#lab-27-10">Lab 27-10</a></li>
<li><a href="#lab-3-11">Lab 3-11</a></li>
<li><a href="#lab-lezione-17-11">Lab/Lezione 17-11</a></li>
<li><a href="#lab-lezione-24-11">Lab/Lezione 24-11</a></li>
<li><a href="#esercizi">Esercizi</a></li>
</ul>
<hr>
<h2 id="metodi-di-comunicazione">METODI DI COMUNICAZIONE<a href="#metodi-di-comunicazione" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><a href="#table-of-contents"> &ndash;&gt; TOC</a>
<img src="/ox-hugo/protocolli_intro_sintesi.png" alt=""></p>
<p>I protocolli hanno senso se condivisi, bisogna definire degli <strong>standard</strong>
comuni.</p>
<ul>
<li><code>ISO/OSI</code> &ndash;&gt; standard <strong>de iure</strong>, prima progettato su carta.</li>
</ul>
<p>Sviluppato su 7 livelli come in Figura 1. Il pacchetto viene &ldquo;inviato&rdquo;
dallo strato fisico di un host all&rsquo;altro, poi viene &ldquo;depacchettizzato&rdquo;.</p>
<ol>
<li><strong>Livello fisico</strong> : interessante dal punto di vista elettronico.</li>
<li><strong>Livello di collegamento</strong>: stabilisce come vengono strutturati i pacchetti
appena prima che vengano trasmessi fisicamente.Il pacchetto a questo
stadio viene anche chiamato <strong>frame</strong> (es. contiene dei bit per sincronizzare le schede di rete prima
della configurazione effettiva).</li>
<li><strong>Livello di rete</strong> Livello centrale, si occupa dell&rsquo;instradamento dei pacchetti.</li>
<li><strong>Livello di trasporto</strong>: trasporto dei pacchetti nella rete (nodi).</li>
<li><strong>Livello di sessione</strong>: vuole ricreare un&rsquo;astrazione di alto livello, ri-orgranizzando
i pacchetti.</li>
<li><strong>Livello di presentazione</strong>: si occupa di come viene <em>rappresentata</em> l&rsquo;informazione.</li>
<li><strong>Livello di applicazione</strong>: fornisce un&rsquo;interfaccia per le applicazioni
che si interfacciano con la rete.</li>
</ol>

  <figure class="left" >
    <img src="/ox-hugo/osi_layers.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 1: </span>ISO/OSI stack</figcaption>
    
  </figure>


<ul>
<li><strong><code>TCP/IP</code></strong> &ndash;&gt; ha prevalso nello sviluppo di internet.</li>
</ul>
<p>Diversi layer comportano un costo &ndash;&gt; si cerca di snellire lo stack,
diminuendo il numero di livelli. Nonostante ciò, si vuole mantanere
la numerazione precedente (Livello trasporto &ndash;&gt; 4, Livello Rete &ndash;&gt; 3).</p>

  <figure class="left" >
    <img src="/ox-hugo/tcpip.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 2: </span>tcp/ip stack</figcaption>
    
  </figure>


<hr>
<h2 id="protocollo-tcp-ip">PROTOCOLLO TCP/IP<a href="#protocollo-tcp-ip" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><a href="#table-of-contents"> &ndash;&gt; TOC</a></p>

  <figure class="left" >
    <img src="/ox-hugo/htn.png"   />
    
  </figure>


<p>2- <strong>Host to Network</strong> Modifiche del protocollo HTN non dovrebbero impattare il resto della rete:
(es. posso creare una rete universitaria, basta avere l&rsquo;hardware necessario).</p>
<p>3- <strong>Network</strong>: Protocollo per la consegna dei pacchetti da un host mittente
ad un destinatario. Ci si occupa semplicemente dell&rsquo;invio dei pacchetti,
non ci si preoccupa di sessioni, pacchetti mancanti, congestione, o simili.</p>
<p>4- <strong>Transport</strong>: servizio di consegna con impegno tra due <em>processi applicativi</em>
che stanno eseguendo su due host terminali. (es TCP, UDP);</p>
<p>5- <strong>Application</strong>: lo vedremo in seguito.</p>
<p>i layer 3 e 4 sono sempre essenzialmente quelli, possono cambiare spesso i livelli
2 e 5 nelle telecomunicazioni!</p>

  <figure class="left" >
    <img src="/ox-hugo/clessidra.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 3: </span>Modello a clessidra</figcaption>
    
  </figure>


<p>(es. Alcune applicazioni potrebbero avere la necessità di sfruttare il protocollo
TCP perchè <strong>vuole garantire la consegna di tutti i pacchetti</strong> ).</p>
<p>(es. A livello host to network, una rete wireless potrebbe preoccuparsi della
garanzia di consegna dei pacchetti. In questo modo risolvo <strong>localmente</strong> un possibile
problema di non consegna dei pacchetti. Se non me ne preoccupo localmente, un&rsquo;altro
host dall&rsquo;altra parte del mondo potrebbe ricevere dei dati non completi.)</p>
<p>(solitamente ci si occupa dell&rsquo;affidabilità a livello <strong>end to end</strong>, a me interessa
che le applicazioni comunichino correttamente!)</p>
<p>&ndash;&gt; <strong>morale</strong>: posso decidere di risolvere i problemi in diversi layer dello stack,
quindi a seconda del contesto si possono spostare alcune funzioni in altri livelli
dello stack.</p>
<p>Non tutti i dispositivi(nodi) implementano tutto lo stack, si possono basare
soltanto su alcuni layer. Switch e bridge sono dispositivi di livelo 2,
che basano il loro funzionamento <strong>soltanto</strong> sul livello 2 (non sanno nulla
del protocolli IP ad esempio)! Il concetto è estendibile: un <strong>router</strong>
legge fino al livello 3, quindi fino all&rsquo;indirizzo IP!</p>

  <figure class="left" >
    <img src="/ox-hugo/switch.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 4: </span>Dispositivi Livello 2</figcaption>
    
  </figure>


<p>Tuttavia esistono delle eccezioni, come gli switch di livello 3, quindi
anche qua c&rsquo;è flessibilità.</p>
<p><strong>Deep packet inspection:</strong> &ndash;&gt; quando si parla di dispositivi che sono in
grado di analizzare più in profondità i pacchetti: riesce a leggere informazioni
anche a livelli più alti dello stack.</p>
<hr>
<h2 id="htn--introduzione">(HTN) INTRODUZIONE<a href="#htn--introduzione" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><a href="#table-of-contents"> &ndash;&gt; TOC</a></p>
<p>Gli scopi del livello Host to Network sono:</p>
<ul>
<li><strong><code>interconnessione</code></strong> tra due o più host;</li>
<li><strong><code>trasmisionne di dati</code></strong> tra host interconnessi;</li>
<li><strong><code>connessione</code></strong> di un host a internet;</li>
</ul>
<p>Nello stack TCP/IP questi 3 aspetti sono fortemente interconnessi
tra di loro.</p>
<p>Alcuni esempi:</p>
<ul>
<li><strong>LAN</strong> wired: Ethernet;</li>
<li><strong>LAN</strong> wireless: 802.11x;</li>
<li><strong>PAN</strong>: (Bluetooth);</li>
<li>Mediante <strong>modem</strong>;</li>
<li><strong>WAN</strong> wireless;</li>
</ul>
<p>L&rsquo;unità informativa è chiamata <code>frame</code> (host-
router/switch, router/switch-router/switch, host-host).</p>
<p>Come anticipato, il livello H2N comprende 2 sottolivelli:</p>
<ol>
<li>Livello &ldquo;<strong>fisico</strong>&quot;:
ci si riferisce alla vera e propria connessione &ldquo;fisica&rdquo; tra gli host
(cavo coassiale, fibra ottica, trasmissione radio, modem);</li>
<li>Livello &ldquo;<strong>data link</strong>&quot;: che si occupa dell&rsquo;incapsulamento e invio
dei dati tra gli host.</li>
</ol>
<h3 id="modalità-di-trasmissione">Modalità di trasmissione<a href="#modalità-di-trasmissione" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ol>
<li><strong><code>Unicast</code></strong> &ndash;&gt; un mittente e un destinatario;</li>
<li><strong>Multicast</strong> &ndash;&gt; comunicazione tra un mittente e un gruppo di destinatari;</li>
<li><strong>Anycast</strong> &ndash;&gt; mittente che vuole comunicare con <strong>un</strong> mittente in un gruppo;</li>
<li><strong><code>Broadcast</code></strong> &ndash;&gt; mittente che vuole comunicare un&rsquo;informazione a tutti;</li>
</ol>
<h3 id="tipi-fisici-di-collegamento">Tipi fisici di collegamento<a href="#tipi-fisici-di-collegamento" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ol>
<li>
<p><code>Mezzo broadcast</code> Un mezzo broadcast è un mezzo attraverso il quale un host invia informazioni
a tutti gli host collegati. Si può sfruttare un dispositivo broadcast per
riservare delle informazioni (ad es.) ad alcune interfacce di rete.</p>
</li>
<li>
<p><code>Mezzo punto a punto</code> collegamento pensato per fornire comuncazione tra 2
punti soltanto.</p>
<ul>
<li><strong>Half-Duplex</strong>: collegamento che permette ad un solo host di inviare dati sul mezzo fisico
in un determinato instante.</li>
<li><strong>Full-Duplex</strong>: collegamento bidirezionale, collegamenti interni dedicati
per entrambe le direzioni (nel caso di un punto a punto).</li>
</ul>
</li>
</ol>
<p>E' importante capire bene la differenza tra <strong>modalità di trasmissione</strong> e
<strong>tipi fisici di collegamento</strong>. Infatti, a prescindere dal mezzo, un
protocollo può prevedere molteplici modalità di trasmissione.</p>
<h2 id="htn--lan-e-ethernet">(HTN) LAN e ETHERNET<a href="#htn--lan-e-ethernet" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><a href="#table-of-contents"> &ndash;&gt; TOC</a></p>
<h3 id="introduzione">Introduzione<a href="#introduzione" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Rete che consente la comunicazione tra dispositivi a livello locale.
Una rete locale può anche essere estesa a livello cittadino, o regionale.
Essa ha un <em>numero limitato di nodi</em>!</p>
<p><code>Backbone LAN</code> &ndash;&gt; Lan dedicate a collegare tante altre reti. Sono dorsali informatiche
che permettono la comunicazione ad alta velocità (solitamente tramite fibra ottica) tra
due punti anche molto distanti tra di loro. Sono di proprietà delle grandi aziende
di telecomunicazioni. In Italia, uno dei principali backbone network è la rete universitaria
GARR che collega attraverso reti sottomarine in fibra ottical&rsquo;università Federico II di Napoli
alla città di New York.</p>
<h3 id="scheda-di-rete">Scheda di rete<a href="#scheda-di-rete" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Un host connesso a internet ha un dispositivo fatto apposta per il protocollo H2N,
prende il nome di &ldquo;scheda di rete&rdquo;. La scheda di rete si occupa del frame (in certi casi
anche di una minima parte della logica), mentre
solitamente il sistema operativo si occupa solo delle <strong>informazioni logiche</strong>.
Quindi in realtà quando si parla di H2N non bisogna immaginarsi il dispositivo (pc, tablet) ma
la vera e propria scheda di rete.</p>
<h3 id="topologie">Topologie<a href="#topologie" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ol>
<li><code>BUS</code> &ndash;&gt; Consiste in un cavo che collega tutti gli host, i messaggi
vengono inviati a tutti gli host come segnali elettrici, ma accettati
solo dal reale destinatario. Il problema è che se il cavo si rompe in
qualsiasi punto, la rete si rompe e non funziona più.</li>
<li><code>ANELLO</code> &ndash;&gt; Un host che riceve un pacchetto si chiede se il pacchetto
è destinato a lui. Se non è per lui, quell&rsquo;host <strong>inoltra</strong> il pacchetto!
L&rsquo;host destinatario assorbe il pacchetto quando gli arriva.</li>
<li><code>STELLA</code> &ndash;&gt; Gli host sono connessi ad un dispositivo centrale dedicato.
Si riescono a raggiungere distanze maggiori (due host possono essere
distanti &ldquo;2 cavi&rdquo;). La rottura di un collegamento provoca solo
l&rsquo;interruzione della connessione con un host. Il problema è che
se si rompe il dispositivo centrale (o si congestiona) la rete
si rompe o si rallenta.</li>
</ol>
<h3 id="protocollo-ethernet">Protocollo Ethernet<a href="#protocollo-ethernet" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Protocollo per realizzare <strong>reti locali</strong>. (Nello stack TCP/IP siamo
sempre nel livello h2n.) Questo protocollo era inizialmente progettato per funzionare
su reti cablate con <strong>topologia a BUS</strong> (velocità nell&rsquo;ordine dei Mbit, quando venne ideata). Ora le schede di
rete reggono velocità anche a livello di Gbit. Teoricamente
il protocollo Ethernet può essere implementato anche con cavi ottici.
In realtà al giorno d&rsquo;oggi questo protocollo è usato con topologia a stella,
molto più sicura e diffusa.</p>
<ul>
<li>Il cavo bus deve avere due &ldquo;terminatori&rdquo; che assorbono la corrente.</li>
<li><strong>Motivi del successo di ethernet:</strong>
<ol>
<li>Poco costosa;</li>
<li>Flessibile e si presta a diverse tecnologie/topologie;</li>
<li>Rapida diffusione iniziale che ha preso il controllo del mercato;</li>
</ol>
</li>
</ul>
<p>Vediamo ora alcuni aspetti fondamentali del protocollo ethernet:</p>
<p><strong><code>Indirizzo MAC</code></strong>:</p>
<p>Gli indirizzi MAC sono gli identificatori usati nel protocollo ethernet.</p>
<p>Esempio: 81:F4:A3:AA:9C:49 &ndash;&gt; 6 byte (8 bit ogni coppia). Questo
tipo di indirizzo è detto <strong>flat</strong>: le cifre non hanno un valore
&ldquo;posizionale&rdquo;. Soltanto i primi 3 byte servono per identificare
il produttore della scheda di rete: con questo stratagemma si evita
di generare indirizzi hardware uguali tra produttori diversi.</p>
<p>Questi indirizzi valgono <strong>per la stessa rete locale</strong>. Ovviamente
la rete funziona correttamente se questi indirizzi sono <strong>univoci</strong>!
Ogni indirizzo MAC è associato ad un&rsquo;interfaccia di rete (a livello Hardware).
Essenzialmente viene scritto all&rsquo;interno della scheda di rete dal
produttore stesso.</p>
<p>Non ci sono misure forti che permettono a chi controlla l&rsquo;host
di &ldquo;camuffare&rdquo; l&rsquo;indirizzo MAC che il sistema operativo usa per
inviare i pacchetti.</p>
<ul>
<li>FF-FF-FF-FF-FF-FF: <strong>indirizzo di broadcast</strong>, serve per identificare
comunicazioni broadcast in reti ethernet.</li>
</ul>
<p>All&rsquo;interno del <strong>frame</strong> del pacchetto inviato viene inserito
l&rsquo;indirizzo MAC del destinatario. In una topologia BUS, a livello
elettrico tutti ricevono fisicamente il pacchetto, a livello logico
lo riceve soltanto il destinatario. Di default, l&rsquo;interfaccia di rete
confronta il suo indirizzo MAC con quello inserito all&rsquo;interno del frame.
Ci sono alcune eccezioni:</p>
<ul>
<li>Il frame contiene l&rsquo;indirizzo destinatario broadcast;</li>
<li>Sull&rsquo;host sta eseguendo un software di sniffing. In questo caso
l&rsquo;interfaccia di rete si dice in modalità <strong>promiscua</strong>.</li>
</ul>
<p>L&rsquo;indirizzo IP non basta da solo principalmente per 2 motivi:</p>
<ol>
<li>Se l&rsquo;indirizzo IP fosse salvato nella NIC al posto dell&rsquo;indirizzo MAC,
quando il dispositivo si connette ad una diversa rete locale,
quell&rsquo;indirizzo all&rsquo;interno della scheda dovrebbe essere riconfigurato
ogni singola volta!</li>
<li>Le NIC non sarebbero in grado di sopportare protocolli diversi da IP.</li>
</ol>
<p><strong><code>Frame Ethernet</code></strong>:</p>
<ol>
<li>
<p><strong>Preambolo</strong>: sequenza di 8 byte che serve alle interfacce di rete
per comunicare correttamente a livello fisico. (&ldquo;Framing&rdquo;)
L&rsquo;ultimo byte è una sequenza che indica la fine del preambolo,
l&rsquo;ultimo bit di questa ultima sequenza è sempre 1.
Del preambolo si preoccupa solo l&rsquo;interfaccia di rete, poi quella
sequenza viene &ldquo;scartata&rdquo;, il S.O. non se ne preoccupa.</p>
</li>
<li>
<p><strong>Indirizzo destinatario</strong> (6 byte):
se in questo indirizzo tutti i byte sono settati a 1 allora
il frame ethernet è detto frame <strong>broadcast</strong>.</p>
</li>
<li>
<p><strong>Indirizzo sorgente</strong> (6 byte);</p>
</li>
<li>
<p><strong>Camp tipo</strong> (2 byte): serve a implementare il <strong>multiplexing</strong>.
Serve al sistema operativo (destinatario) per capire cosa fare
del pacchetto ricevuto. (Devo essere in grado di collegare i vari livelli,
devo &ldquo;codificare&rdquo; che payload sto trasportando). In altre parole,
serve all’adattatore per sapere a quale dei protocolli dello strato di rete debba
essere passato il campo dati di ciascun frame ricevuto.</p>
</li>
<li>
<p><strong>CRC</strong>: Informazione di controllo che si trova dopo
il pacchetto dati. Per questo si parla di &ldquo;frame&rdquo;,
perchè il payload viene &ldquo;circondato&rdquo;. Il CRC serve per controllare
l&rsquo;integrità del paccheto: viene calcolato dall&rsquo;interfaccia di rete del mittente
durante l&rsquo;invio del pacchetto con un algoritmo (detto a sua volta CRC). Il
destinatario calcola a sua volta il CRC (in base ai dati che gli arrivano) e lo confronta
con il CRC ricevuto. Se i due valori coincidono, allora la
trasmissione è avvenuta correttamente.</p>
<p>Il CRC(Controllo di Ridondanza Ciclico) viene generato sulla base del contenuto di 2,3,4 e dei dati (payload).</p>
</li>
</ol>
<p>Il payload (dati) si trova tra la 4  e la 5 sequenza.</p>
<p><strong><code>MTU</code></strong>: (<em>Maximum Transfer Unit</em>) Dimensione massima trasferibile sulla rete, a livello
di pacchetto. (solitamente 1500 byte)
Il livello H2N usa lo <strong>stuffing</strong> per &ldquo;completare&rdquo; i pacchetti
che hanno dimensione minore di 46 byte.
Tutte le schede di rete di una rete ethernet devono essere
configurate con la stessa MTU! (essendo un campo comunque variabile,
un amministratore di rete potrebbe decidere di cambiarne il valore)</p>
<p><strong><code>Protocollo ARP</code></strong>:
(<em>Adress resolution protocol</em>)</p>
<p>Di base quando si vuole inviare un pacchetto ad un host, non
si conosce l&rsquo;indirizzo MAC del destinatario.
Il protocollo ARP prende come in input l&rsquo;indirizzo IP del
destinatario, e come output ha l&rsquo;indirizzo MAC del destinatario.</p>
<ul>
<li>
<p><strong>Richiesta ARP</strong>: messaggio broadcast che ha come payload
l&rsquo;indirizzo IP che l&rsquo;host sta cercando. Questo messaggio
viene ricevuto da tutti gli host connessi alla rete, ma
l&rsquo;unico che risponde è chi ha l&rsquo;indirizzo IP ricercato.
La risposta contiene l&rsquo;indirizzo MAC associato a l&rsquo;indirizzo
IP iniziale.</p>
<p><strong>La risposta è unicast</strong>, il destinatario manda il MAC adress
solo a chi l&rsquo;ha richiesto.</p>
<p>Questo modo di richiedere un indirizzo MAC è effettuabile
soltanto su una rete <strong>contenuta</strong>: è difficile mandare un
messaggio broadcast saturando una rete che connette troppi host.
I pacchetti usati per richieste / risposte ARP sono pacchetti
&ldquo;assestanti&rdquo; soltanto a livello h2n, non hanno un livello 3.
Per questo è un &ldquo;sottoprotocollo&rdquo; dell&rsquo;Ethernet.</p>
<p>Il fatto che non sia riuscito ad ottenere l&rsquo;indirizzo MAC
del destinatario (nel caso in cui effettivamente non ci sia),
è un&rsquo;informazione implicita che si ottiene grazie ad un &ldquo;<strong>timeout</strong>&rdquo;.</p>
</li>
<li>
<p><strong>ARP Table</strong>: cache che conserva il mapping IP-MAC per
un certo periodo di tempo, per migliorare la performance.
La ARP cache è gestita totalmente a livello di sistema operativo.
Un amministratore potrebbe voler configurare staticamente
delle associazioni IP-ARP, nel caso in cui la rete
sia fissa e non avvezza a cambiamenti di varia natura.</p>
<p>Esempio di una entry:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Indirizzo Ip</th>
<th>Indirizzo MAC</th>
<th>TTL</th>
</tr>
</thead>
<tbody>
<tr>
<td>222.222.222.221</td>
<td>88-B2-2F-54-1A-0F</td>
<td>13:45:00</td>
</tr>
</tbody>
</table>
<p><strong><code>Protocollo CSMA/CD</code></strong>:</p>
<p>Protocollo di accesso al mezzo che serve per rilevare le collisioni tra pacchetti nelle reti
ethernet. Nelle reti wifi si vuole evitare la collisione, il suo protocollo prende
infatti il nome di CSMA/CA &ndash;&gt; (<em>Collision Avoidance</em>), più
complesso e costoso!</p>
<ul>
<li><strong>Carrier sense</strong>: L&rsquo;interfaccia di rete prima di iniziare a inviare pacchetti
si mette in ascolto, cerca di capire se qualcuno sta già trasmettendo;</li>
<li><strong>Listen while talking</strong>: le interfacce di rete cercano di rilevare
segnali in ingresso anche durante la trasmissione. In tal caso
si assume che avvenga una collisione, quindi l&rsquo;interfaccia si ferma
di inviare dati. &ndash;&gt; L&rsquo;interfaccia invia un segnale <strong>JAMMING</strong>, anche
tutte le altre interfacce si mettono in pausa!</li>
<li><strong>Inter Frame Gap (IFG)</strong>: lunghezza del pacchetto dati più piccolo.
I frame emessi da un host sono distanziati da un Inter Frame Gap,
in modo da permettere agli altri host di capire la fine di un
frame e l&rsquo;inizio di un altro.
Un host prima di iniziare a trasmettere su un canale, sta in
ascolto per la durata di un IFG in modo da capire se il canale
sia libero o meno.</li>
<li><strong>Ritardo pseudo-casuale</strong> &ndash;&gt; si ri-inizia a inviare i pacchetti
applicando un ritardo casuale che si spera sia diverso per i vari
segnali.</li>
<li><strong>Binary Exponential Back-off (BEB)</strong> &ndash;&gt; algoritmo che decide
il delay della trasmissione. Il delay è compreso tra [0, 2^n-1],
quindi aumenta esponenzialmente ad ogni &ldquo;stop&rdquo;.</li>
</ul>

  <figure class="left" >
    <img src="/ox-hugo/BEB.png"   />
    
  </figure>


<p>Il calcolo viene effettuato in base alla velocità della rete, non
si lavora mai con tempi assoluti. Aumentando esponenzialmente la
grandezza dell&rsquo;insieme di valori da cui si sceglie il ritardo di
trasmissione, l&rsquo;host riesce a riadattare la trasmissione al traffico
che attualmente è presente nella rete. In presenza di sovraccarico,
ovviamente il ritardo di trasmissione è molto alto!</p>
<h3 id="tipi-di-dispositivi">Tipi di dispositivi<a href="#tipi-di-dispositivi" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p><strong><code>Hub</code></strong> (l1): ripetitore di segnale, sono deprecati.
Funge da centro stella, ogni volta che gli arrivano segnali elettrici
lui li replica e lo manda su tutte le porte. Replica anche le collisioni!</p>
<p><strong><code>Switch</code></strong> (l2): consentono un <strong>inoltro selettivo</strong> dei frame:
più host possono comunicare contemporaneamente nella stessa rete.
Gli unici dati che lo swtich legge del frame ethernet sono gli
indirizzi MAC.</p>
<ul>
<li><strong>store and forward</strong>: gli switch solitamente prima di inoltrare
il pacchetto lo memorizza per analizzarlo. Se uno switch finisce
la memoria (in caso di congestione) alcuni pacchetti potrebbero
essere persi/eliminati. Questo meccanismo permette allo switch
di gestire le collisioni fisiche!</li>
</ul>
<!-- raw HTML omitted -->
<ol>
<li><strong>filtraggio</strong>: tabella di filtraggio che conserva la corrispondenza
tra indirizzo MAC dell&rsquo;host, la porta a cui è collegata e il tempo
di vita di questa informazione.
Inizialmente uno switch un hub che cerca di ottenere informazioni
sugli host collegati alle sue porte.
Da non configurato inoltra a tutti e inizia ad auto-apprendere in
base ai pacchetti che gli arrivano.</li>
</ol>
<!-- raw HTML omitted -->
<ol>
<li><strong>inoltro</strong> dei frame al MAC adress corretto.</li>
</ol>
<p>Se ad uno switch arrivano delle richieste provenenti da due host
(uno malevolo che ha copiato il MAC adress di un altro) con lo
stesso indirizzo MAC, lo switch si auto-configura ogni volta!
Ovviamente alcuni swtich più costosi hanno dei meccanismi di
difesa più complessi.</p>
<p>Se uno switch riceve pacchetti da troppi mac adress differenti,
finisce la memoria e non riesce più ad aggiornare la
tabella di filtraggio. In tal caso, lo switch torna a lavorare
come un hub, inoltrando i pacchetti a tutte le porte!</p>
<ul>
<li><strong>paradigma cut-through</strong>: Il frame viene inoltrato all&rsquo;address
destinatario senza aspettare che il frame arrivi completamente.
Questo aumenta le prestazioni, ma permette meno funzionalità
(come l&rsquo;implementazione del controllo di integrità CRC, che
a volte è invece implementato in alcuni switch.);</li>
</ul>
<p><strong><code>Bridge</code></strong> (l2): implementa tutta la logica degli switch, ma con
alcune funzionalità aggiuntive.</p>
<ol>
<li>
<p><strong>Bridging trasparente</strong>: se si mettono in collegamento a livello
2 dei protocolli H2N differenti. Permette ad esempio l&rsquo;inoltro
di pacchetti tra protocollo ethernet e protocollo wi-fi.
Quindi il sistema di indirizzamento è lo stesso.</p>
</li>
<li>
<p><strong>Bridging non trasparente</strong>: in grado di lavorare con logiche
di &ldquo;conversione&rdquo; di protocolli di comuncazione. Sono molto
meno popolari.</p>
</li>
<li>
<p><strong>Bridging virtuale</strong>: switch che funzionano su interfacce
virtuali. Nonostante sia essenzialmente uno switch, viene
chiamato gergalmente &ldquo;bridge&rdquo;.</p>
</li>
</ol>
<p>Esistono anche dispositivi come gli <strong>splitter</strong>, molto economici e utili
per far partire due cavi da uno solo di ingresso.</p>
<h3 id="interconnesioni-di-lan">Interconnesioni di LAN<a href="#interconnesioni-di-lan" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Una soluzione tipica per creare reti estese è quello di
creare delle reti LAN multi livello. Gli switch usati nei diversi
livelli possono anche essere di diversa natura, alcuni possono
essere più veloci di altri in base alle esigenze. Nel caso qui
presentato, lo switch centrale deve essere più potente degli altri.
Anche le singole porte degli switch possono reggere diverse velocità.</p>

  <figure class="left" >
    <img src="/ox-hugo/interconnessione.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 5: </span>Rete Lan multilivello</figcaption>
    
  </figure>


<p>In una rete del genere, un guasto potrebbe impattare il funzionamento
di una grossa parte della rete. Per questo a volte si potrebbero
creare delle reti con percorsi ridondanti, in modo da dare percorsi
alternativi ai pacchetti.</p>
<ul>
<li>Problema: in presenza di reti <strong>cicliche</strong>, i messaggi broadcast circolano
all&rsquo;infinito!</li>
<li>Soluzione: <code>spanning tree protocol</code> &ndash;&gt; in una rete con dei collegamenti
ridondanti vengono disabilitati un certo numero di link sufficiente
a rimuovere i cicli! Quindi serve una &ldquo;logica&rdquo; che possa aiutare
a individuare questi cicli, usando dei messaggi sonda.</li>
</ul>
<p>Il problema del protocollo ARP rimane: i messaggi broadcast impallano
la rete!</p>
<hr>
<h2 id="htn--interconnessioni-di-rete-e-accesso-a-internet">(HTN) INTERCONNESSIONI DI RETE E ACCESSO A INTERNET<a href="#htn--interconnessioni-di-rete-e-accesso-a-internet" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><a href="#table-of-contents"> &ndash;&gt; TOC</a></p>
<h3 id="intro">Intro<a href="#intro" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p><em>Ci avviamo verso il livello 3, ma senza abbandonare il livello 2&hellip;</em></p>
<p>Cerchiamo di capire come gestire reti <strong>indipendenti</strong> e <strong>eterogenee</strong>;
Internet è una <strong>rete globale</strong>: permette la comunicazione tra (<em>i</em>) dispositivi
e tra (<em>ii</em>) reti!
Lo scopo, alla fine, è quello di far comunicare in modo trasparente un <em>client</em>
e un <em>server</em>, che sono nodi della rete.
Internet può ad esempio essere visto come insieme di <strong>Autonomus Systems</strong>,
oppure un&rsquo;insieme di <strong>nomi</strong>.</p>
<p>Approfondimento sugli <strong>Autonomus System</strong></p>
<p>📃 <a href="https://theelandor.github.io/prova/reti/aut_system.html">Autonomus Systems (telegram)</a></p>
<p>Alcuni principi che bisogna seguire:</p>
<ul>
<li><strong>Survivability</strong> (<em>resilienza</em>): se tra due host esiste un percorso, la comunicazione tra
quei due host deve funzionare. Quindi ad esempio in caso di guasto di una via,
bisogna essere in grado di sfruttarne un&rsquo;altra.</li>
<li><strong>Forma a clessidra</strong>: IP implementa il minimo che serve per far funzionare
la rete globale. Le funzionalità aggiuntive vengono spartite negli altri
livelli dello stack \(\rightarrow\) IP è un protocollo <strong>non affidabile</strong>.</li>
<li><strong>Mancanza di stato</strong>: l&rsquo;intelligenza della rete è mantenuta sugli host e
non sui router. Questo è permesso grazie al <em>packet switching</em>: al contrario,
nelle reti telefoniche, l&rsquo;intelligenza era nella rete, mentre ai bordi i
dispositivi erano molto semplici (dispositivi elettro-meccanici).</li>
<li><strong>Net neutrality</strong>: ogni pacchetto deve essere gestito allo stesso modo,
indipendentemente dal tipo di dato o dal tipo di connessione ad esempio.
Questo principio, per motivi di varia natura, attualmente non è sempre
rispettato.</li>
</ul>
<h3 id="connessioni-xdsl">Connessioni xDSL<a href="#connessioni-xdsl" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Metodo maggiormente utilizzato attualmente: il mio pc è collegato alla centrale
telefonica (cabina in strada), a sua volta collegata <strong>digitalmente</strong> alla rete
della compagnia telefonica corrispondente. Il <strong><code>Protocollo PPP</code></strong> è stato
appositamente pensato per collegamenti punto-punto nell&rsquo;accesso residenziale.</p>
<h3 id="ppp--approfondimento">PPP (approfondimento)<a href="#ppp--approfondimento" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Protocollo(di livello 2) appositamente creato per la gestione dei collegamenti point-to-point,
ad esempio nelle connessioni cablate xDSL.</p>
<ol>
<li><strong>Modularità</strong>: supporta molti protocolli nei livelli superiori.</li>
<li>Supporto all'<strong>autenticazione</strong>: garanzia non scontata a livello di sicurezza!</li>
<li><strong>Rilevamento di errori</strong> (non risoluzione), molto importante in quasi ogni protocollo.</li>
<li>Supporto all'<strong>IP Dinamico</strong>:</li>
</ol>
<p><strong><code>Metodo di incapsulazione</code></strong>: PPP deve saper ricevere pacchetti di varia natura
e trasmetterli correttamente. 2 componenti principali: (<em>i</em>) Link Control Protocol e
(<em>ii</em>) Network Control Protocol</p>
<ul>
<li><strong>Link Control Protocol</strong> &ndash;&gt; relativa al mezzo fisico;</li>
<li><strong>Network Control Protocol</strong> &ndash;&gt; comunicazione con il livello IP;</li>
</ul>
<p><strong><code>Principi del PP</code></strong>:</p>
<ol>
<li><strong>Packet Framing</strong> con <strong>Bit transparency</strong>: il protocollo PPP deve riuscire a
trasferire dati binari di qualsiasi natura.</li>
<li><strong>Connection liveness</strong>: individua problemi a livello di link, nel caso viene
comunicato un errore a livello 3.</li>
<li><strong>Error detection</strong>, già accennato prima;</li>
<li><strong>Network Layer address negotiation</strong>: viene fornito supporto ai diversi
protocolli di rete comunicanti per configurare gli indirizzi di rete.
(&ldquo;Si configura il livello 3 a partire dal livello 2&rdquo;)</li>
</ol>
<p>Nonostante questo protocollo debba funzionare su dispositivi dedicati, è
abbastanza complesso e con molte funzionalità.
Alcune funzionalità di cui <strong>NON</strong> si occupa il PPP:</p>
<ol>
<li><strong>Error Correction</strong>;</li>
<li><strong>Flow Control</strong>: quando la connessione viene stabilita (ad esempio da casa
mia alla centralina), si stabilisce un &ldquo;tasso nominale&rdquo; di velocità che
però <em>non viene verificata</em> da parte di PPP. Questo non toglie che il
controllo non venga effettuato in altri livelli dello stack.</li>
<li><strong>Sequence</strong>: l&rsquo;ordine dei pacchetti non viene verificato.</li>
</ol>
<p><strong><code>Fasi principali di una connessione</code></strong></p>
<ol>
<li>Stabilire la <strong>connessione</strong>: quando intendo comunicare delle informazioni,
prima apro una connessione aprendo un canale. Si usa quindi un paradigma
diverso dal &ldquo;packet switching&rdquo;, dato che abbiamo un canale dedicato.</li>
<li><strong>Autenticazione</strong>, che in alcuni casi è facoltativa.</li>
<li><strong>Configurazione</strong> del protocollo di rete.</li>
<li>(fase di comunicazione)</li>
<li><strong>Terminazione</strong></li>
</ol>
<p>Dato che si usa un protocollo orientato alla connessione, si può suddividere
quest&rsquo;ultima in diverse fasi (Figura 6)</p>

  <figure class="left" >
    <img src="/ox-hugo/autome.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 6: </span>PPP, automa a stati finiti</figcaption>
    
  </figure>


<p><strong><code>Data Frame del PPP</code></strong></p>

  <figure class="left" >
    <img src="/ox-hugo/pppframe.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 7: </span>Frame del protocollo PPP</figcaption>
    
  </figure>


<p><strong><code>Byte Stuffing</code></strong></p>
<p>Tecnica che si usa per distinguere il byte &lt;01111110&gt; &ldquo;flag&rdquo; dallo
stesso byte se è un dato logico. Per farlo, aggiunge un byte extra analogo
prima di ogni byte (&lt;01111110&gt;) dato.
E' una sorta di operazione di &ldquo;escaping&rdquo;: il destinatario se trova due byte
(&lt;01111110&gt;) di fila, scarta il primo, il secondo lo considera &ldquo;dato&rdquo; e
continua la ricezione.</p>
<hr>
<h2 id="vlan">VLAN<a href="#vlan" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>📃 <a href="https://theelandor.github.io/prova/reti/vlan.html">VLAN</a></p>
<h2 id="ip--livello-ip">(IP) Livello IP<a href="#ip--livello-ip" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><a href="#table-of-contents"> &ndash;&gt; TOC</a></p>
<h3 id="indirizzo-ip">Indirizzo IP<a href="#indirizzo-ip" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>32 bit &ndash;&gt; 4 byte, più piccolo di un&rsquo;indirizzo MAC!
Si usa una dotted notation, in cui ogni numero (in decimale) rappresenta
un byte. Indicativamente quindi si possono generare circa 4 miliardi di
indirizzi \((2^{32})\). In questo caso si parla di <strong><code>IPv4</code></strong>.</p>
<p>Per quando riguarda questo corso, studiamo degli indirizzi di <em>lunghezza fissa</em>,
indipendentemente dal contesto o tipo di comunicazioni. La lunghezza variabile
potrebbe permettere di avere più flessibilità, ma i costi a livello di comunicazione
sono troppo alti e svantaggiosi.</p>
<p>Lo spazio di indirizzamento è <strong>gerarchico</strong> e strutturato, a differenza ad
esempio di ethernet (ricordiamoci dei problemi legati ai messaggi ARP broadcast
che rischiano di intasare la rete). Le gerarchie fanno si che si possano
inviare i dati in modo selettivo in contesti anche complessi.</p>
<p>Gli indirzzi IP sono indirizzi <strong>logici</strong>, e possono essere:</p>
<ol>
<li>Assegnati a ogni host <strong>permanentemente</strong> (in modo statico);</li>
<li>Assegnati <strong>dinamicamente</strong>, ad esempio al momento del boot;</li>
</ol>
<p>Un classico esempio di un dispositivo che necessita di un indirizzo statico è un
server, che deve fornire un servizio permanente e accessibile.
Al contrario, noi utenti, spesso usiamo dei protocolli per ottenere l&rsquo;indirizzo dinamicamente.
Ovviamente, assegnamo l&rsquo;indirizzo IP ad un&rsquo;interfaccia di rete. Tuttavia, ogni interfaccia
può avere diversi indirizzi IP.</p>
<ul>
<li>Perchè c&rsquo;è bisogno anche di un indirizzo fisico oltre all&rsquo;indirizzo logico? &ndash;&gt; per
motivi di performance: in modo da poter &ldquo;delegare&rdquo; all&rsquo;hardware alcune funzionalità
specifiche (il filtraggio, ad esempio)! Queste stesse funzionalità potrebbero
anche essere gestite a più alto livello, ma potrebbero risultare più lente essendo
implementate a livello software.</li>
</ul>
<h3 id="componenti-dell-indirizzo-ip">Componenti dell&rsquo;Indirizzo IP<a href="#componenti-dell-indirizzo-ip" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>In questo caso i byte hanno un valore posizionale per garantire la
scalabilità e una struttura gerarchica:</p>
<ol>
<li>Network ID</li>
<li>Host ID</li>
</ol>
<p>Gli indirizzi IP sono gestiti per &ldquo;insiemi&rdquo;. Spesso indirizzi IP simili
corrispondono ad host vicini geograficamente e logicamente tra loro.</p>
<h3 id="indirizzi-ip-speciali">Indirizzi IP <em>speciali</em><a href="#indirizzi-ip-speciali" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>
<p><strong><code>Network Address</code></strong>: <strong>155.185.0.0</strong> \(\rightarrow\)
la parte dell&rsquo;indirizzo relativa all&rsquo;host ha tutti i byte pari a 0.</p>
</li>
<li>
<p><strong><code>Indirizzo di Broadcast</code></strong>: <strong>128.211.255.255</strong> \(\rightarrow\) la parte dell&rsquo;indirizzo
relativa all&rsquo;host ha tutti i byte con bit pari a 1. Questo messaggio può
essere destinato ad una qualsiasi rete.</p>
</li>
<li>
<p><strong><code>Limited Broadcast Adress</code></strong>: <strong>255.255.255.255</strong> \(\rightarrow\) tutti i bit settati a 1.
Permette di mandadre un messaggio broadcast sulla rete fisica locale.
Un pacchetto con questo indirizzo IP <em>non viene</em> inoltrato dai router, perchè
è destinato soltanto alla rete locale, è simile ad un arp request.</p>
</li>
<li>
<p><strong><code>This Host on This Network</code></strong>: 0.0.0.0 \(\rightarrow\) tutti i bit settati a 0. Identifica
un host non ancora configurato correttamente.</p>
</li>
<li>
<p><strong><code>Loopback Address</code></strong>: <strong>127.0.0.1</strong> \(\rightarrow\) permette la comunicazione a livello internet
sulla stessa macchina, localmente. <em>Tutti gli indirizzi di loopback iniziano per 127</em>!</p>
</li>
<li>
<p><strong><code>Indirizzi privati</code></strong> ammissibili: indirizzi <em>non routable</em>, che possono
essere usati localmente senza autorizzazione.
(<em>i</em>) 10.0.0.0/8
(<em>ii</em>) 172.16.0.0/12
(<em>iii</em>) 192.168.0.0/16</p>
</li>
</ul>
<p><strong><code>Natting</code></strong> &ndash;&gt; se ho una rete privata ma voglio comunicare con una rete
esterna, che magari non accetta gli indirizzi IP locali. E' una funzione
offerta dal router locale.
📃 <a href="https://theelandor.github.io/prova/reti/ip_header_nat.html">Approfondimento Natting</a></p>
<h3 id="gestione-indirizzi-e-domini">Gestione indirizzi e domini<a href="#gestione-indirizzi-e-domini" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p><strong><code>Jon Postel</code></strong> [1943-1998]: definito <em>lo zar dei numeri</em>, direttore di <strong>IANA</strong>, si occupava
di garantire gli standard di internet.
Uno dei compiti di IANA, era quello di garantire la corretta gestione degli indirizzi IP,
la loro unicità e la loro corretta struttura gerarchica.
Data la decentralizzazione di internet, la IANA cerca di delegare i compiti ai
provider di internet internazionali. Per prima cosa, si creano delle sotto-associazioni
che gestiscono dei &ldquo;blocchi&rdquo; di indirizzi IP, a livello geografico (quindi &ldquo;asegnando&rdquo;
i <em>Network ID</em>). A loro volta verrano istituiti dei provider nazionali, regionali,
e così via.</p>
<p><strong><code>Classi di Indirizzi IP</code></strong>: differenziano il numero di byte assegnati al netid.
Per classificarli e riconoscerli, hanno delle sequenze iniziali distintive. Ad
esempio, gli indirizzi che iniziano con 10 sono di classe B, quindi hanno i primi
2 byte dedicati al netid. Quelli di classe C i primi 3 byte, ecc&hellip;
Le 3 classi più interessanti, che tratteremo in questo corso, sono A,B,C.</p>

  <figure class="left" >
    <img src="/ox-hugo/classi.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 8: </span>Classi di Indirizzi IP</figcaption>
    
  </figure>



  <figure class="left" >
    <img src="/ox-hugo/classi2.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 9: </span>Dimensioni delle classi di indirizzi</figcaption>
    
  </figure>


<p>Queste classi di indirizzi erano pensate per essere assegnate ai diversi internet service
provider. Ovviamente, negli anni sono entrati in scena aspetti economico/politici:
gli ISP comprano una determinata classe in base al bisogno di connettività che devono
fornire ai loro utenti.</p>
<p>Tendenzialmente i gestori di classi A sono grossi paesi o grosse aziende (<em>o ricche</em>, <del>che a volte
nemmeno ne hanno bisogno</del> ) come Apple, IBM, IANA, e altre.</p>
<p><strong><code>Indirizzi Classless</code></strong>: per motivi gestionali e di flessibilità, spesso si può indicare esplicitamente
quale parte dell&rsquo;indirizzo è dedicata al N.ID o H.ID.
Per fare questo tipo di ripartizione, si usa la notazione <strong><code>CIDR</code></strong> \(\rightarrow\) <strong>a.b.c.d/n</strong></p>
<p>Esempio di indirizzo classless: 192.168.1.1/23</p>
<h3 id="formato-del-datagramma-ip">Formato del datagramma IP<a href="#formato-del-datagramma-ip" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Ogni pacchetto IP può essere lungo fino a 64kbyte. Sicuramente
nell&rsquo;header sono contenuti (<em>i</em>) indirizzo sorgente (<em>ii</em>) indirizzo
destinazione.
Se si pensa all&rsquo;interità dello stack, ci si ricorda che questo pacchetto
verrà passato ai livelli sottostanti prima di essere trasmesso, quindi
al livello ethernet. La grandezza massima del frame ethernet era determinata
dall&rsquo;M.C.U: in ogni caso non poteva superare i 1500byte. Come faccio
quindi a incapsulare un pacchetto grande fino a 64KByte?</p>
<p>&ndash;&gt; Esistono 2 approcci per risolvere questo problema:</p>
<ol>
<li>Faccio in modo che questo pacchetto IP sia più piccolo e possa
essere incapsulato;</li>
<li>Si cerca di <strong>frammentare</strong> il datagramma IP, quindi bisogna fornire
delle informazioni all&rsquo;interno del datagramma che possano servire
all&rsquo;host che riceve il frammento per &ldquo;ricostruire&rdquo; l&rsquo;intero pacchetto.</li>
</ol>

  <figure class="left" >
    <img src="/ox-hugo/ipdatagram.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 10: </span>Formato del datagram IP</figcaption>
    
  </figure>


<ul>
<li><strong>VERS</strong> &ndash;&gt; informazioni sulla versione;</li>
<li><strong>HLEN</strong> &ndash;&gt; lunghezza dell&rsquo;header del datagram, si suppone una certa
flessibilità del protocollo.</li>
<li><strong>Service type</strong> &ndash;&gt; bitmap che comunica delle informazioni relativi
al pacchetto. In Figura 11 si può vedere meglio la struttura di questa
sequenza lunga 8 bit.</li>
<li><strong>Identification</strong> &ndash;&gt; intero che identifica il datagram;</li>
<li><strong>Flags</strong> &ndash;&gt; flag che segnalano la frammentazione;</li>
<li><strong>Offset</strong> &ndash;&gt; identificano il frammento rispetto al pacchetto originale;</li>
<li><strong>Time to Live</strong> &ndash;&gt; contatore che ci mostra quanti router questo pacchetto
può percorrere prima di essere scartato.</li>
<li><strong>Protocol</strong> &ndash;&gt; contiene informazioni verso il livello 4, indica quale
protocollo può usare i dati contenuti nel datagram.</li>
<li><strong>Checksum</strong> &ndash;&gt; controllo di integrità sull'<em>header</em>, quindi non ci si
preoccupa per ora del payload. (Come al solito, in IP ci si mantiene
il più leggeri possibili).</li>
<li><strong>Ip-options</strong> &ndash;&gt; campo opzionale di grandezza variabile, serve per fare
debugging di rete.</li>
<li><strong>Padding</strong> &ndash;&gt; serve per fare in modo che l&rsquo;intero header abbia lunghezza
che sia un multiplo di 32 bit. Simile al &ldquo;byte stuffing&rdquo;.</li>
</ul>

  <figure class="left" >
    <img src="/ox-hugo/typeofs.png"   />
    
      <figcaption class="center" ><span class="figure-number">Figure 11: </span>Service type sequence</figcaption>
    
  </figure>


<h2 id="ip--subnetting">(IP) Subnetting<a href="#ip--subnetting" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/subnetting.html">Subnetting</a></li>
</ul>
<h2 id="ip--ip-routing">(IP) Ip routing<a href="#ip--ip-routing" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/ip_routing.html">IP routing</a></li>
<li>📃 <a href="https://theelandor.github.io/prova/reti/ip_routing_2.html">Ip routing 2</a></li>
</ul>
<hr>
<h2 id="bgp">BGP<a href="#bgp" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Breve introduzione al protocollo BGP:</p>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/bgp.html">BGP</a></li>
</ul>
<h2 id="tcp">(TCP)<a href="#tcp" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/151122.html">Livello 4, 15/11/22, UDP e intro a TCP</a></li>
<li>📃 <a href="https://theelandor.github.io/prova/reti/221122.html">Livello 4, 22/11/22, segmento TCP, TWH</a></li>
<li>📃 <a href="https://theelandor.github.io/prova/reti/tcp2.html">Livello 4, 29/11/22, TCP, Sliding Window</a></li>
</ul>
<h2 id="dns">DNS<a href="#dns" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/061122.html">DNS, 06/12/22</a></li>
</ul>
<h2 id="dhcp">DHCP<a href="#dhcp" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/121222.html">DHCP, teoria+minilab, 12/12/22</a></li>
</ul>
<h2 id="security">Security<a href="#security" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/sec.html">Intro security</a></li>
<li>📃 <a href="https://theelandor.github.io/prova/reti/sec2.html">Public Key Distribution</a></li>
<li>📃 <a href="https://theelandor.github.io/prova/reti/sec3.html">Stack of Secure Protocols</a></li>
</ul>
<h2 id="email">Email<a href="#email" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/email.html">Posta elettronica</a></li>
</ul>
<h2 id="lab-6-10">Lab 6-10<a href="#lab-6-10" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><a href="#table-of-contents"> &ndash;&gt; TOC</a></p>
<ul>
<li><strong><code>Collegamenti dritti</code></strong>: si usano quando si vogliono collegare
dispositivi che lavorano a livelli diversi dello stack TCP/IP,
come un host e uno switch.</li>
<li><strong><code>Collegamenti incrociati</code></strong>: quando si collegano dispositivi
che lavorano allo stesso livello dello stack TCP/IP, come
due host o due switch.</li>
</ul>
<h3 id="ifconfig">ifconfig<a href="#ifconfig" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Si usa il comando <strong>ifconfig</strong> per mostrare le interfacce attualmente
<em>attive</em> nell&rsquo;host.
Alcune flag/opzioni utili:</p>
<ul>
<li>
<p><strong>-a</strong>: mostra tutte le interfacce, anche le non attive. (i) <strong>lo</strong> è
un&rsquo;interfaccia virtuale locale che il SO usa per le comunicazioni
tra processi locali.</p>
</li>
<li>
<p><strong>&lt;nome_interfaccia&gt;</strong>: mostra le informazioni sull&rsquo;interfaccia specificata;
(i) HWaddr è il MAC adress dell&rsquo;interfaccia;
(ii) MTU è la maximum transfer unit;</p>
</li>
</ul>
<h3 id="ip">ip<a href="#ip" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Si usa il comando <strong>ip</strong> per interagire con lo stack TCP/IP. Per lavorare
a livello 2 si usa il comando <strong>ip link</strong>. Esso elenca tutte le interfacce
di rete disponibili nel sistema, simile al comando <code>ifconfig -a</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">eros@eros-ThinkPad-T430:~/website$ ip link
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span style="color:#ae81ff">1000</span>
	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: enp0s25: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc fq_codel state DOWN mode DEFAULT group default qlen <span style="color:#ae81ff">1000</span>
	link/ether 28:d2:44:0e:4e:f4 brd ff:ff:ff:ff:ff:ff
3: wlp3s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc mq state UP mode DORMANT group default qlen <span style="color:#ae81ff">1000</span>
	link/ether 6c:88:14:86:08:08 brd ff:ff:ff:ff:ff:ff
4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc noqueue state DOWN mode DEFAULT group default
	link/ether 02:42:f5:40:4e:45 brd ff:ff:ff:ff:ff:ff
</code></pre></div><ul>
<li><strong>ip link show eth0</strong> per ottenere informazioni su quell&rsquo;interfaccia di rete;</li>
<li><strong>ip link set eth0 up</strong> per accendere l&rsquo;interfaccia;</li>
<li><strong>ip link set eth0 down</strong> per spegnere l&rsquo;interfaccia;</li>
</ul>
<h3 id="come-configurare-una-rete">Come configurare una rete<a href="#come-configurare-una-rete" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ol>
<li>
<p>Per prima cosa bisogna assegnare l&rsquo;indirizzo IP all&rsquo;interfaccia.
Eseguire questo comando corrisponde anche all&rsquo;accensione dell&rsquo;interfaccia.
Dopo l&rsquo;esecuzione del comando, sull&rsquo;output di ifconfig compare la
linea corrispondente alle informazioni degli indirizzi ip.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ifconfig eth0 192.168.1.1
</code></pre></div><p>Per spegnere l&rsquo;interfaccia e rimuovere l&rsquo;indirizzo ip:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ifconfig eth0 <span style="color:#ae81ff">0</span> down
</code></pre></div><p>Per vedere gli indirizzi assegnati ad un interfaccia:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ip addr show dev eth0
ifconfig eth0
</code></pre></div><p>Per aggiungere un indirizzo ip  ad un interfaccia.
In questo caso devo sia assegnare l&rsquo;indirizzo che attivare l&rsquo;interfaccia.
ifconfig invece lo fa in automatico, per questo a volte risulta più comodo.
Il comando ip è pensato per gestire più indirizzi IP in una stessa
interfaccia, quindi risulta più articolato.
Usando il comando <code>ifconfig eth0 0 down</code> viene spenta l&rsquo;interfaccia
e rimosso soltanto <em>il primo</em> indirizzo ip.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ip addr add dev eth0 192.168.1.1/24
</code></pre></div></li>
<li>
<p>Dopo aver acceso le interfacce e aver assegnato l&rsquo;indirizzo IP,
si può testare la connessione usando <code>ping</code>. Se questa operazione
ha successo, si può consultare l'<em>arp table</em> usando uno di questi
due comandi:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">root@m1:~# arp
Address                  HWtype  HWaddress           Flags Mask            Iface
192.168.1.4              ether   02:04:06:1b:57:4b   C                     eth0
192.168.1.3                      <span style="color:#f92672">(</span>incomplete<span style="color:#f92672">)</span>                              eth0

root@m1:~# ip neigh
192.168.1.4 dev eth0 lladdr 02:04:06:1b:57:4b STALE
192.168.1.3 dev eth0  FAILED
</code></pre></div><p>Può tornare utile il comando <code>ip neigh flush all</code>, che pulisce
l&rsquo;arp table.</p>
</li>
<li>
<p><strong>ifupdown</strong> &ndash;&gt; tool che serve per configurare in modo permanente
la configurazione di una macchina. Prima di agire, conviene resettare
le configurazioni temporanee.</p>
<p>La configurazione è contenuta nel file /etc/network/interfaces.
In questo modo le informazioni date configurano la rete come
se fosse stato usato ifconfig. Ecco un semplice esempio di
configurazione</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">root@m2:~# cat /etc/network/interfaces
<span style="color:#75715e"># interfaces(5) file used by ifup(8) and ifdown(8)</span>
<span style="color:#75715e"># Include files from /etc/network/interfaces.d:</span>
source-directory /etc/network/interfaces.d

auto eth0

iface eth0 inet static
address 192.168.1.1
</code></pre></div><ul>
<li>auto &ndash;&gt; la configurazione si attiva al boot;</li>
<li>per attivare immediatamente la configurazione dell&rsquo;interfaccia
di eth0 si può usare il comando <code>ifup eth0</code> ;</li>
<li>per disattivare la configurazione permanente dell&rsquo;interfaccia
di eth0 si usa <code>ifdown eth0</code>;</li>
</ul>
</li>
</ol>
<h3 id="tmux">TMUX<a href="#tmux" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Alcuni comandi utili per la gestione delle finestre:</p>
<pre tabindex="0"><code class="language-example" data-lang="example">- logout --&gt; ctrl-d
- modalità comandi --&gt; ctrl-b
- detach --&gt; CMD + d
- split verticale --&gt; CMD + %
- split orizzontale --&gt; CMD + &quot;
- spostamento --&gt; CMD + freccina
- scroll --&gt; CMD + pageup/pagedown
- nuova finestra --&gt; CMD + c
- scelta finestra --&gt; CMD + numero
</code></pre><h3 id="tcpdump-e-ping">tcpdump e ping<a href="#tcpdump-e-ping" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Tool usato per sniffare il traffico di rete di una determinata scheda.
(i) -e sta per ethernet, in modo da limitarsi alle informazioni del livello 2.
(ii) -i serve per specificare l&rsquo;interfaccia.
Esempio di output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">root@m2:~# tcpdump -nei eth0
tcpdump: verbose output suppressed, use -v or -vv <span style="color:#66d9ef">for</span> full protocol decode
listening on eth0, link-type EN10MB <span style="color:#f92672">(</span>Ethernet<span style="color:#f92672">)</span>, capture size <span style="color:#ae81ff">262144</span> bytes
10:53:49.007880 02:04:06:9c:eb:4a &gt; ff:ff:ff:ff:ff:ff, ethertype ARP <span style="color:#f92672">(</span>0x0806<span style="color:#f92672">)</span>, length 42: Request who-has 192.168.1.2 tell 192.168.1.1, length <span style="color:#ae81ff">28</span>
10:53:49.007905 02:04:06:1b:57:4b &gt; 02:04:06:9c:eb:4a, ethertype ARP <span style="color:#f92672">(</span>0x0806<span style="color:#f92672">)</span>, length 42: Reply 192.168.1.2 is-at 02:04:06:1b:57:4b, length <span style="color:#ae81ff">2</span>
</code></pre></div><p>Può essere utile anche il comando <code>arping</code>: il test di connessione
viene effettuato mandando tante richieste ARP, consecutivamente.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">root@m1:~# arping -i eth0 192.168.1.2
root@m2:~# tcpdump -nei eth0
tcpdump: verbose output suppressed, use -v or -vv <span style="color:#66d9ef">for</span> full protocol decode
listening on eth0, link-type EN10MB <span style="color:#f92672">(</span>Ethernet<span style="color:#f92672">)</span>, capture size <span style="color:#ae81ff">262144</span> bytes
10:56:56.242261 02:04:06:9c:eb:4a &gt; ff:ff:ff:ff:ff:ff, ethertype ARP <span style="color:#f92672">(</span>0x0806<span style="color:#f92672">)</span>, length 42: Request who-has 192.168.1.2 tell 192.168.1.1, length <span style="color:#ae81ff">28</span>
10:56:56.242283 02:04:06:1b:57:4b &gt; 02:04:06:9c:eb:4a, ethertype ARP <span style="color:#f92672">(</span>0x0806<span style="color:#f92672">)</span>, length 42: Reply 192.168.1.2 is-at 02:04:06:1b:57:4b, length <span style="color:#ae81ff">28</span>
</code></pre></div><hr>
<h2 id="lab-20-10">Lab 20-10<a href="#lab-20-10" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><a href="#table-of-contents"> &ndash;&gt; TOC</a></p>
<h3 id="introduzione">Introduzione<a href="#introduzione" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Lo scopo è quello di configurare 2 reti locali separate, con un host
centrale che fa da router.</p>

  <figure class="left" >
    <img src="/ox-hugo/router.png"   />
    
  </figure>


<p><strong>LAN1: 192.168.1.0</strong>
Quindi gli indirizzi ip vanno da 192.168.1.1 a 192.168.1.254, perchè
192.168.1.255 è un&rsquo;indirizzo speciale non assegnabile (di broadcast);</p>
<p><strong>LAN2: 192.168.2.0</strong></p>
<h3 id="configurazione--temporanea">Configurazione (temporanea)<a href="#configurazione--temporanea" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li><strong>H1</strong> &ndash;&gt; <code>ifconfig eth0 192.168.1.1/24</code>. Per essere sicuri, è meglio specificare la netmask;</li>
</ul>
<p>Il router H2 ha due interfacce di rete, vanno configurate entrambe:</p>
<ul>
<li><strong>H2</strong> &ndash;&gt; <code>ifconfig eth0 192.168.1.254/24</code>
<code>ifconfig eth1 192.168.2.254/24</code></li>
</ul>
<p>Dato che H2 è il router, deve avere le due interfacce che appartengono alle
due reti diverse. E' prassi che il suo indirizzo IP parta dagli ultimi
disponibili, in modo da essere riconoscibile ad occhio.</p>
<h3 id="tabella-di-routing">Tabella di routing<a href="#tabella-di-routing" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>La tabella di routing contiene le informazioni necessarie all&rsquo;host
per poter comunicare in rete.
Per visualizzare la tabella di routing, si usa il seguente comando
<code>route -n</code> \(\downarrow\)</p>

  <figure class="left" >
    <img src="/ox-hugo/h1routing.png"   />
    
  </figure>


<p>In questo caso, l&rsquo;host H1 è solo in grado di comunicare localmente,
riesce a inviare pacchetti a indirizzi IP &ldquo;locali&rdquo;. Infatti nella
tabella è presente solo un record (quindi una regola di routing), applicabile agli indirizzi IP
che iniziano con <strong>192.168.1.0</strong>.</p>
<ul>
<li>
<p><strong>Destination</strong>: applico questa riga a tutti i pacchetti destinati all'
indirizzo di rete specificato.</p>
</li>
<li>
<p><strong>Genmask</strong>: specifica la netmask degli indirizzi a cui è destinata
questa reogla di routing. Dato che nella configurazione di questa
interfaccia di rete abbiamo specificato &ldquo;/24&rdquo;, la netmask avrà
i primi 3 byte tutti settati a 1.</p>
</li>
<li>
<p><strong>Gateway</strong>: 0.0.0.0 significa che il pacchetto
va inviato tramite host to network, quindi localmente!
Nel caso di questa specifica interfaccia verrà quindi sfruttato il
protocollo ethernet.</p>
<p><em>Situazione</em>: da H1 uso il comando ping specificando un generico indirizzo IP.</p>
<p>Cosa succede?</p>
<p>La prima cosa che viene fatta dall&rsquo;host è il consulto della tabella di routing, per capire cosa
fare dei pacchetti che devono essere inviati a quell&rsquo;indirizzo. Se il gateway ha un valore  (diverso da 0.0.0.0) allora il pacchetto
va inoltrato tramite il router specificato! Altrimenti il pacchetto
viene inviato tramite protocollo ethernet.</p>
<p>Per vedere la tabella di routing i può anche usare <code>iproute</code>:</p>
</li>
</ul>

  <figure class="left" >
    <img src="/ox-hugo/iproute.png"   />
    
  </figure>


<ul>
<li><strong>Scope link</strong> significa che il pacchetto va inviato sfruttando il livello
&ldquo;link&rdquo;, quindi il livello2. Per eth0 questo livello è ethernet.</li>
</ul>
<blockquote>
<p>Seguno ora alcuni esempi di comunicazione.</p>
</blockquote>
<ul>
<li>
<p>da H1 uso questo comando: <code>ping 192.168.1.2</code></p>
<p>&ndash;&gt; il sistema cerca di inviare richieste arp, perchè
la tabella di routing dice che questo indirizzo dovrebbe essere raggiungibile
a livello 2. Nessuno risponde all&rsquo;arp request, quindi il timeout scade
e viene stampato &ldquo;host unreachable&rdquo;.</p>
</li>
<li>
<p>da H1 uso il comando: <code>ping 192.168.2.2</code></p>
<p>&ndash;&gt; ottengo l&rsquo;errore
&ldquo;Network is unreachable&rdquo;. Infatti nella tabella di routing non
esistono entry che specificano regole per questa destinazione.</p>
</li>
<li>
<p>da H1 configuro in modo diverso l&rsquo;interfaccia, usando <code>ip addr dev eth0 192.168.1.1</code>.
&ndash;&gt; In questo caso, se poi se uso <code>ping 192.168.1.254</code>, ottengo <em>host unreachable</em>, perchè
ip non capisce da solo qual&rsquo;è la netmask! Infatti essa deve essere necessariamente
specificata alla fine dell&rsquo;indirizzo. In tal caso viene aggiornata correttamente la route table e riesco
a pingare un host che si trova sulla rete locale.
Con ifconfig invece, anche se la netmask non viene specificata, lui interpreta il comando
e capisce che (ad esempio) 192 è l&rsquo;inizio di un&rsquo;indirizzo di classe C (per convenzione).
Quindi usare <strong>ifconfig 192.168.0.1</strong> è equivalente a usare <strong>ip addr dev eth0 192.168.1.1/24</strong>.</p>
</li>
</ul>
<p>Usando invece <code>ifconfig eth0 10.0.0.1</code>, l&rsquo;indirizzo viene di default interpretato come  indirizzo di classe A.
Esiste un modo per configurare un&rsquo;interfaccia di rete senza far aggiornare
la route table anche usando ifconfig: si usa il comando <code>ifconfig eth0 10.0.0.1/32</code>.
Alla fine è come se usassi <code>ip add add dev eth0 10.0.0.1</code> senza specificare la netmask.</p>
<h3 id="configurazione-del-router">Configurazione del router<a href="#configurazione-del-router" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Di base un host non si comporta come un router: infatti se riceve un&rsquo;indirizzo
ip diverso dal proprio esso viene scartato! Bisogna quindi configurare l&rsquo;host
centrale in modo da farlo comportare come un router (che inoltra i pacchetti).
In linux si può usare modificando un&rsquo;opzione del kernel:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sysctl -w net.ipv4.ip_forward<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p>Dopo aver fatto ciò, è importante &ldquo;istruire&rdquo; gli host di livello 3 della
rete, in modo da fargli capire come raggiungere gli indirizzi ip &ldquo;esterni&rdquo;,
non raggiungibili a livello 2.
Bisogna semplicemente aggiungere una regola di routing.</p>
<p>Ci si posiziona su H1 e si lancia il seguente comando, con cui si specifica
che per raggiungere la rete 2 si deve passare per il router con indirizzo
<strong>192.168.1.254</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">route add -net 192.168.2.0/24 gw 192.168.1.254
</code></pre></div>
  <figure class="left" >
    <img src="/ox-hugo/routerconfig.png"   />
    
  </figure>


<blockquote>
<p>Seguono ora alcuni esempi di comunicazione.</p>
</blockquote>
<ul>
<li>
<p>da H1 uso <code>ping 192.168.2.2</code></p>
<p>&ndash;&gt; per prima cosa H1 cerca di capire qual&rsquo;è l&rsquo;indirizzo del router, che
risponde fornendo il suo indirizzo MAC. Dopo aver fatto ciò,
invia un pacchetto con IP destinazione <strong>192.168.2.2</strong>, <em>al router</em>. Esso inoltra poi il pacchetto
e cerca di inviare delle arp request, ovviamente non trovando l&rsquo;host
con l&rsquo;ip richiesto. Il timeout scade, e viene ritornato un messaggio
di errore.</p>
</li>
<li>
<p>da H1 uso <code>ping 192.168.2.1</code>:
&ndash;&gt; in questo caso la comunicazione non sembra
funzionare. Questo perchè H3 non è ancora configurato per raggiungere
H1 per inviare le risposte! In realtà quindi i pacchetti vengono <em>inviati</em>
correttamente.</p>
</li>
<li>
<p>da H3 uso &ndash;&gt; <code>route add -net 192.168.1.0/24 gw 192.168.2.254</code>
a questo punto il comando ping precedente funziona nel suo complesso
correttamente!</p>
</li>
<li>
<p>da H1 uso <code>route add default gw 192.168.1.254</code>:
&ndash;&gt; molto spesso usata
nei contesti reali, quando in una rete locale ho soltanto un router
che mi manda verso l&rsquo;esterno della rete (verso internet);
L&rsquo;host specificato viene usato come <strong>gateway predefinito</strong>;</p>
</li>
</ul>

  <figure class="left" >
    <img src="/ox-hugo/defaultgateway.png"   />
    
  </figure>


<p>In questo caso è ben visibile il record che corrisponde al router di
default (Destination &ndash;&gt; 0.0.0.0)</p>
<ul>
<li>da H1 uso <code>ping 192.168.3.1</code>
&ndash;&gt; <strong>&ldquo;Net unreachable&rdquo;</strong>: il router infatti controlla la
sua tabella di routing e non trova una rete compatibile, quindi
rimanda indietro l&rsquo;errore.</li>
</ul>
<p>Per eliminare una regola di routing si possono usare i seguenti comandi:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">route del -net default
route del -net 192.168.2.0/24
</code></pre></div><p>Con il seguente comando si specifica una regola di routing per uno specifico
host.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">route add -host 192.168.1.254 dev eth0
</code></pre></div><h3 id="configurazione-permanente">Configurazione permanente<a href="#configurazione-permanente" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Sotto viene riportato il file di configurazione di H1.
Dopo <strong>post-up</strong> viene specificato un comando che viene eseguito <em>dopo</em>
l&rsquo;attivazione dell&rsquo;interfaccia di rete.
Con la specifica <strong>&ldquo;gateway&rdquo;</strong> semplicemente si specifica il default gateway.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">auto eth0
iface eth0 inet static
  address 192.168.1.1/24
  gateway 192.168.1.254
  post-up route add -net 192.168.2.0/24 gw 192.168.1.254
</code></pre></div><p>Per configurare H2 invece:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">auto eth0 eth1
iface eth0 inet static
  address 192.168.1.254/24

iface eth1 inet static
  address 192.168.2.254/24
</code></pre></div><h2 id="lab-27-10">Lab 27-10<a href="#lab-27-10" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/cidr.html">Laboratorio Subnetting</a></li>
</ul>
<h2 id="lab-3-11">Lab 3-11<a href="#lab-3-11" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/031122.html">Laboratorio WLAN</a></li>
</ul>
<h2 id="lab-lezione-17-11">Lab/Lezione 17-11<a href="#lab-lezione-17-11" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Breve introduzione sul Natting (telegram + presenza) + Laboratorio in presenza:</p>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/ip_header_nat.html">Laboratorio Natting</a></li>
</ul>
<h2 id="lab-lezione-24-11">Lab/Lezione 24-11<a href="#lab-lezione-24-11" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Breve introduzione ai Firewall + Laboratorio:</p>
<ul>
<li>📃 <a href="https://theelandor.github.io/prova/reti/241122.html">Laboratorio Firewall</a></li>
</ul>
<h2 id="esercizi">Esercizi<a href="#esercizi" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>📃 <a href="https://theelandor.github.io/prova/es1reti.html">Esercizio routing 20/10/22</a></p>

      </div></div>

  

  
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>







  
</div>

</body>
</html>
